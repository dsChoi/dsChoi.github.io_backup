<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Object Oriented Programmer</title>
  
  <subtitle>To Improve My Life</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://dschoi.github.io/"/>
  <updated>2020-04-28T12:34:36.355Z</updated>
  <id>https://dschoi.github.io/</id>
  
  <author>
    <name>Stones</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>chapter-13. 서브클래싱과 서브타이핑</title>
    <link href="https://dschoi.github.io/2020/04/21/objects-13/"/>
    <id>https://dschoi.github.io/2020/04/21/objects-13/</id>
    <published>2020-04-21T13:00:57.000Z</published>
    <updated>2020-04-28T12:34:36.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-서브클래싱과-서브타이핑"><a href="#13-서브클래싱과-서브타이핑" class="headerlink" title="13. 서브클래싱과 서브타이핑"></a>13. 서브클래싱과 서브타이핑</h1><p><strong>상속의 두가지 용도</strong></p><ul><li>타입 계층을 구현<ul><li>부모 클래스는 자식 클래스의 일반화(genralization)</li><li>자식 클래스는 부모 클래스의 특수화(specialization)</li></ul></li><li>코드 재사용<ul><li>간단한 선언으로 부모 클래스의 코드를 재사용할수 있다.</li><li>재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기에 변경하기 어려운 코드를 얻게 될 확률이 높다. </li></ul></li></ul><a id="more"></a><p>동일한 메세지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. </p><p><strong>객체지향 프로그래밍과 객체기반 프로그래밍</strong></p><blockquote><ul><li><p><strong>객체기반 프로그래밍(Object-Based Programming)</strong> : 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식</p></li><li><p><strong>객체지향 프로그래밍(Object-Oriented Programming)</strong> : 객체기반 프로그래밍의 한 종류 </p><ul><li><strong>상속 과 다형성</strong> 을 지원한다는 점에서 객체기반 프로그래밍과 차별화됨.</li></ul></li><li><p>프로토타입 기반언어 관점 </p><ul><li>객체지향 프로그래밍 : 클래스를 사용하는 프로그래밍 방식</li><li>객체기반 프로그래밍 : 클래스 없이 객체만을 사용하는 프로그래밍 방식</li></ul></li></ul></blockquote><h2 id="01-타입"><a href="#01-타입" class="headerlink" title="01. 타입"></a>01. 타입</h2><h3 id="개념-관점의-타입"><a href="#개념-관점의-타입" class="headerlink" title="개념 관점의 타입"></a><strong>개념 관점의 타입</strong></h3><ul><li><strong>심볼(symbol)</strong> : 타입에 이름을 붙인 것.</li><li><strong>내연(intension)</strong> : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다.</li><li><strong>외연(extension)</strong> : 타입에 속하는 객체들의 집합이다. <code>프로그래밍 언어</code> 타입의 경우에는 자바, 루비, 자바스크립트, C가 속한 집합이 외연을 구성한다.</li></ul><h3 id="프로그래밍-언어-관점의-타입"><a href="#프로그래밍-언어-관점의-타입" class="headerlink" title="프로그래밍 언어 관점의 타입"></a><strong>프로그래밍 언어 관점의 타입</strong></h3><ul><li><p>타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의</p></li><li><p>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공</p></li></ul><h3 id="객체지향-패러다임-관점의-타입"><a href="#객체지향-패러다임-관점의-타입" class="headerlink" title="객체지향 패러다임 관점의 타입"></a>객체지향 패러다임 관점의 타입</h3><ul><li>개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.</li><li>프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다. </li></ul><p><strong>객체지향 프로그래밍 관점에서의 타입</strong></p><blockquote><p>객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.</p></blockquote><h2 id="02-타입-계층"><a href="#02-타입-계층" class="headerlink" title="02. 타입 계층"></a>02. 타입 계층</h2><h3 id="타입-사이의-포함관계"><a href="#타입-사이의-포함관계" class="headerlink" title="타입 사이의 포함관계"></a>타입 사이의 포함관계</h3><p><strong>프로그래밍 언어 타입의 인스턴스 집합</strong></p><p><img src="/2020/04/21/objects-13/image-20200421221801071.png" alt="image-20200421221801071"></p><p>*<em>타입은 공통적인 특성을 가진 객체들을 포함하는 집합이다. *</em></p><p><strong><img src="/2020/04/21/objects-13/image-20200421222212523.png" alt="image-20200421222212523"></strong></p><p><strong>일반화와 특수화 관계를 가진 계층으로 표현</strong></p><p><img src="/2020/04/21/objects-13/image-20200421222459318.png" alt="image-20200421222459318"></p><p><strong>타입 계층을 구성하는 두 타입간의 관계</strong></p><ul><li><p>슈퍼타입 : 더 일반적인 타입</p><ul><li>슈퍼타입의 특징<ul><li>집합이 다른 집합의 모든 멤버를 포함</li><li>타입 정의가 다른 타입보다 좀더 일반적</li></ul></li></ul></li></ul><ul><li><p>서브타입 : 더 특수한 타입</p><ul><li>서브타입의 특징<ul><li>집합에 포함되는 인스턴스들이 더 큰 집합에 포함</li><li>타입 정의가 다른 타입보다 좀더 구체적이다.</li></ul></li></ul></li></ul><p><strong>일반화</strong> : 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과</p><p><strong>특수화</strong> : 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과</p><h3 id="객체지향-프로그래밍과-타입-계층"><a href="#객체지향-프로그래밍과-타입-계층" class="headerlink" title="객체지향 프로그래밍과 타입 계층"></a>객체지향 프로그래밍과 타입 계층</h3><p><strong>퍼블릭 인터페이스 관점의 슈퍼타입과 서브타입 정의</strong></p><ul><li>슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의</li><li>서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의</li></ul><p>상속과 다형성의 관계를 이해하기 위한 출발점</p><p><code>서브타입의 인스턴스</code> 는 <code>수퍼타입의 인스턴스</code>로 간주될 수 있다.</p><h2 id="03-서브클래싱과-서브타이핑"><a href="#03-서브클래싱과-서브타이핑" class="headerlink" title="03. 서브클래싱과 서브타이핑"></a>03. 서브클래싱과 서브타이핑</h2><h3 id="언제-상속을-사용해야-하는가"><a href="#언제-상속을-사용해야-하는가" class="headerlink" title="언제 상속을 사용해야 하는가?"></a>언제 상속을 사용해야 하는가?</h3><p>아래 두 질문에 대해 모두 충족할때 상속 사용 가능</p><ul><li><p>상속 관계가 is-a 관계를 모델링하는가?</p><ul><li>자식 클래스는 부모 클래스다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.</li></ul></li><li><p>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?</p><ul><li>클라이언트 입장에서는 부모 클래스와 자식 클래스의 차이점을 몰라야한다. 이를 자식 클래스와 부모클래스 사이의 <code>행동 호환성</code> 이라고 한다.</li></ul></li></ul><h3 id="클라이언트의-기대에-따라-계층-분리하기"><a href="#클라이언트의-기대에-따라-계층-분리하기" class="headerlink" title="클라이언트의 기대에 따라 계층 분리하기"></a>클라이언트의 기대에 따라 계층 분리하기</h3><p><strong>인터페이스 분리원칙 (Interface Segregation Principle, ISP)</strong></p><blockquote><p>인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙</p></blockquote><p><code>두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기에 상속을 해서는 안된다.</code></p><h3 id="서브클래싱과-서브타이핑"><a href="#서브클래싱과-서브타이핑" class="headerlink" title="서브클래싱과 서브타이핑"></a>서브클래싱과 서브타이핑</h3><ul><li><p>서브클래싱</p><blockquote><p>다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다.</p><p>자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체 할 수 없다. 서브클래싱을 <strong>구현상속</strong> 또는 <strong>클래스 상속</strong>이라고 부르기도 한다. </p></blockquote></li><li><p>서브타이핑</p><blockquote><p>타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다.</p><p>서브타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 이때 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다. 서브 타이핑을 <strong>인터페이스 상속</strong>이라고 부르기도 한다. </p></blockquote></li></ul><p>서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할수 있어야 한다. </p><p>즉 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 <strong>행동호환성</strong> 을 만족시켜야 한다.</p><h2 id="04-리스코프-치환-원칙"><a href="#04-리스코프-치환-원칙" class="headerlink" title="04. 리스코프 치환 원칙"></a>04. 리스코프 치환 원칙</h2><blockquote><p>S형의 각 객체 o1 에 대해 T형의 객체 o2    가 하나 있고, T에 의해 정의된 모든 프로그램 P 에서 T가 S로 치환될 때, P의 동작이 변하지 않으면, S 는 T의 서브타입이다. </p></blockquote><p><strong>서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.</strong></p><h3 id="클라인트와-대체-가능성"><a href="#클라인트와-대체-가능성" class="headerlink" title="클라인트와 대체 가능성"></a>클라인트와 대체 가능성</h3><p>Square, Rectangle 을 대체 할 수 없는 이유는 클라이언트 관점에서 Square와 Rectangle이 다르기 때문이다. </p><p>리스코프 치환 원칙은 자식 클래스가 부모클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다.</p><h3 id="is-a-관계-다시-살펴보기"><a href="#is-a-관계-다시-살펴보기" class="headerlink" title="is-a 관계 다시 살펴보기"></a>is-a 관계 다시 살펴보기</h3><p>is - a 관계로 표현된 문장을 볼때마다 앞에 <code>클라이언트 입장에서</code> 라는 말이 빠져있다고 생각하라. </p><p>is - a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다. </p><p><strong>결론</strong></p><blockquote><p>상속이 서브타이핑을 위해 사용된 경우만 is-a 관계다. </p><p>서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계가 아니다.</p></blockquote><h3 id="리스코프-치환-원칙은-유연한-설계의-기반이다"><a href="#리스코프-치환-원칙은-유연한-설계의-기반이다" class="headerlink" title="리스코프 치환 원칙은 유연한 설계의 기반이다."></a>리스코프 치환 원칙은 유연한 설계의 기반이다.</h3><ul><li>의존성 역전 원칙<ul><li>상위 수준 모듈인 Movie와 하위 수준 모듈인 OverlappedDiscountPolicy 는 모두 추상클래스인 DiscountPolicy에 의존한다. </li></ul></li><li>리스코프 치환 원칙<ul><li>Movie 는 DiscountPolicy 대신 OverlappedDiscountPolicy 와 협력하더라도 아무런 문제가 없다. </li><li>LSP 만족</li></ul></li><li>개방-폐쇄 원칙<ul><li>할인 정책을 추가하기 위해 DiscountPolicy의 자식 클래스를 추가하더라도 Movie에 영향을 주지 않는다. </li><li>기능을 확장하면서 기존 코드를 수정하지 않는다면 OCP 를 만족</li></ul></li></ul><p><strong>DIP, LSP, OCP 가 조합된 유연한 설계</strong></p><img src="/2020/04/21/objects-13/image-20200428212645144.png" alt="image-20200428212645144"><h3 id="타입-계층과-리스코프-치환-원칙"><a href="#타입-계층과-리스코프-치환-원칙" class="headerlink" title="타입 계층과 리스코프 치환 원칙"></a>타입 계층과 리스코프 치환 원칙</h3><ul><li>클래스 상속은 타입 계층을 구현할 수 잇는 다양한 방법 중 하나</li><li>덕 타이핑 기법(?)</li><li>리스코프 치환 원칙을 준수해야만 서브타이핑 관계</li><li>클라이언트 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용되어야한다.<ul><li>슈퍼클래스(?)의 행동이 동일하게 동작해야한다.</li></ul></li></ul><h2 id="05-계약에-의한-설계와-서브타이핑"><a href="#05-계약에-의한-설계와-서브타이핑" class="headerlink" title="05. 계약에 의한 설계와 서브타이핑"></a>05. 계약에 의한 설계와 서브타이핑</h2><p><strong>계약에 의한 설계( Design By Contract, DBC)</strong></p><ul><li>클라이언트가 정상적으로 메서들르 실행하기 위해 만족시켜야 하는 <strong>사전 조건(precondition)</strong></li><li>메서드 실행 된 후에 서버가 클라이언트에게 보장해야 하는 <strong>사후조건(post condition)</strong></li><li>메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 할 <strong>클래스 불변식(classs invariant)</strong></li></ul><p><strong>리스코프 치환 원칙과 계약에 의한 설계 사이의 관계</strong></p><blockquote><p>서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 <code>계약</code> 을 준수해야 한다.</p></blockquote><h3 id="서브타입과-계약"><a href="#서브타입과-계약" class="headerlink" title="서브타입과 계약"></a>서브타입과 계약</h3><ul><li><p>서브타입에 더 강력한 사전 조건을 정의할 수 없다.</p></li><li><p>서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.</p></li><li><p>서브타입에 슈퍼타입과 같거나 더 강한 사후존겅르 정의할 수 있다.</p></li><li><p>서브타입에 더 약한 사후조건을 정의할 수 없다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;13-서브클래싱과-서브타이핑&quot;&gt;&lt;a href=&quot;#13-서브클래싱과-서브타이핑&quot; class=&quot;headerlink&quot; title=&quot;13. 서브클래싱과 서브타이핑&quot;&gt;&lt;/a&gt;13. 서브클래싱과 서브타이핑&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;상속의 두가지 용도&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;타입 계층을 구현&lt;ul&gt;
&lt;li&gt;부모 클래스는 자식 클래스의 일반화(genralization)&lt;/li&gt;
&lt;li&gt;자식 클래스는 부모 클래스의 특수화(specialization)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코드 재사용&lt;ul&gt;
&lt;li&gt;간단한 선언으로 부모 클래스의 코드를 재사용할수 있다.&lt;/li&gt;
&lt;li&gt;재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기에 변경하기 어려운 코드를 얻게 될 확률이 높다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
  </entry>
  
  <entry>
    <title>chapter-12. 다형성</title>
    <link href="https://dschoi.github.io/2020/04/14/objects-12/"/>
    <id>https://dschoi.github.io/2020/04/14/objects-12/</id>
    <published>2020-04-14T01:10:57.000Z</published>
    <updated>2020-04-28T12:28:15.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-12-다형성"><a href="#chapter-12-다형성" class="headerlink" title="chapter 12 . 다형성"></a>chapter 12 . 다형성</h1><p><strong>상속의 목적</strong></p><blockquote><p>상속은 타입 계층을 구조화하기 위해 사용해야한다.</p><p>코드 재사용을 위해 사용해서는 안된다.</p></blockquote><p>상속을 사용하려는 목적</p><ol><li>단순히 코드를 재사용하기 위해서?<ol><li><code>상속을 사용하면 안된다.</code></li></ol></li><li>클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서?</li></ol><a id="more"></a><h2 id="01-다형성"><a href="#01-다형성" class="headerlink" title="01 다형성"></a>01 다형성</h2><p><strong>다형성(Polymorphism)</strong></p><p><strong>다형성의 분류</strong></p><img src="/2020/04/14/objects-12/image-20200414103748874.png" alt="image-20200414103748874" style="zoom:50%;"><ul><li><p>오버로딩 다형성</p><ul><li>하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우</li><li>ex) Money 클래스 안에 서로 다른 타입의 파라미터를 받아 금액을 증가시키는 메서드 plus를 가짐</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">plus</span><span class="params">(Money amount)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">plus</span><span class="params">(BigDecimal amount)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amount)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>강제 다형성</p><ul><li>언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식</li><li>ex) 자바 이항 연산자 ‘+’ 는 정수인 경우 정수 덧셈, 문자열인 경우 연결 연산자로 동작</li></ul></li><li><p>매개변수 다형성</p><ul><li>클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식</li><li>ex) 자바의 List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할수 있게 하고 있다. 따라서 List 인터페이스는 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용할 수 있다.</li></ul></li><li><p>포함 다형성</p><ul><li>메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력</li><li>서브타입 다형성이라고도 부른다.</li><li>특별한 언급없이 다형성이라 할때는 포함 다형성을 의미하는 것이 일반적</li><li>ex)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateMoveiFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fee.minus(discountPolicy.calcuateDiscountAmount(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="02-상속의-양면성"><a href="#02-상속의-양면성" class="headerlink" title="02. 상속의 양면성"></a>02. 상속의 양면성</h2><p>객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위안으로 통합한은 것.</p><p>상속의 목적은 코드의 재사용이 아니다.  상속은 프로그래밍을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.</p><p><strong>상속의 매커니즘을 이해하는데 필요한 개념 5가지</strong></p><ul><li>업캐스팅</li><li>동적 메서드 탐색</li><li>동적 바인딩</li><li>self 참조</li><li>super 참조</li></ul><h3 id="상속을-위한-강의-평가"><a href="#상속을-위한-강의-평가" class="headerlink" title="상속을 위한 강의 평가"></a>상속을 위한 강의 평가</h3><h3 id="데이터-관점의-상속"><a href="#데이터-관점의-상속" class="headerlink" title="데이터 관점의 상속"></a>데이터 관점의 상속</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> Lecture(<span class="string">"객체지향 프로그래밍"</span>, <span class="number">70</span>, Arrays.asList(<span class="number">81</span>,<span class="number">95</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">45</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(<span class="string">"객체지향 프로그래밍"</span>, <span class="number">70</span>, </span><br><span class="line">                                   Arryas.asList(<span class="keyword">new</span> Grade(<span class="string">"A"</span>, <span class="number">100</span>, <span class="number">95</span>), </span><br><span class="line">                                                <span class="keyword">new</span> Grade(<span class="string">"B"</span>, <span class="number">94</span>, <span class="number">80</span>),</span><br><span class="line">                                                 <span class="keyword">new</span> Grade(<span class="string">"C"</span>, <span class="number">79</span>, <span class="number">70</span>),</span><br><span class="line">                                                 <span class="keyword">new</span> Grade(<span class="string">"D"</span>, <span class="number">69</span>, <span class="number">50</span>),</span><br><span class="line">                                                 <span class="keyword">new</span> Grade(<span class="string">"F"</span>, <span class="number">49</span>, <span class="number">0</span>),</span><br><span class="line">                                                )</span><br><span class="line">                                   Arrays.asList(<span class="number">81</span>,<span class="number">95</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">45</span>));</span><br></pre></td></tr></table></figure><p><strong>부모 클래스의 인스턴스를 포함하는 자식 클래스</strong></p><img src="/2020/04/14/objects-12/image-20200414125010481.png" alt="image-20200414125010481" style="zoom:50%;"><p><strong>인스턴스 간의 링크로 표현된 상속 관계</strong></p><img src="/2020/04/14/objects-12/image-20200414125041366.png" alt="image-20200414125041366" style="zoom:50%;"><h3 id="행동-관점의-상속"><a href="#행동-관점의-상속" class="headerlink" title="행동 관점의 상속"></a>행동 관점의 상속</h3><p><strong>행동 관점의 상속이란?</strong></p><blockquote><p>부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미</p></blockquote><h2 id="03-업캐스팅과-동적-바인딩"><a href="#03-업캐스팅과-동적-바인딩" class="headerlink" title="03. 업캐스팅과 동적 바인딩"></a>03. 업캐스팅과 동적 바인딩</h2><h3 id="같은-메시지-다른-메서드"><a href="#같은-메시지-다른-메서드" class="headerlink" title="같은 메시지, 다른 메서드"></a>같은 메시지, 다른 메서드</h3><ul><li>부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 <strong>업캐스팅</strong>이라고 부른다.</li><li>선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 <strong>동적 바인딩</strong> ㅇㅣ라고 부른다. </li></ul><p><strong>개방 -폐쇄 원칙과 의존성 역전 원칙</strong></p><blockquote><p>업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며 이것은 개방-폐쇄 원칙의 의도와 일치한다.</p><p>개방-폐쇄 원칙은 유연하고 확장 가능한 코드를 만들기 위해 의존관계를 구조화하는 방법을 설명한다. 업캐스팅과 동적메서드 탐색은 상속을 이용해 개방-폐쇄 원칙을 따르는 코드를 작성할 때 하부에서 동작하는 기술적인 내부 메커니즘을 설명한다. <code>개방-폐쇄원칙</code>이 <strong>목적</strong>이라면 <code>업캐스팅과 동적 메서드 탐색</code>은 <strong>목적에 이르는 방법</strong>이다. </p></blockquote><h3 id="업캐스팅"><a href="#업캐스팅" class="headerlink" title="업캐스팅"></a>업캐스팅</h3><img src="/2020/04/14/objects-12/image-20200420222051550.png" alt="image-20200420222051550" style="zoom:50%;"><h3 id="동적-바인딩"><a href="#동적-바인딩" class="headerlink" title="동적 바인딩"></a>동적 바인딩</h3><p><strong>정적바인딩</strong></p><p>함수를 호출하는 전통적인 언어들은 호출될 함수를 컴파일 타임에 결정한다. </p><p>이처럼 컴파일 타임에 호출할 함수를 결정하는 방식을 <strong>정적 바인딩(static binding), 초기 바인딩(early binding), 컴파일타임 바인딩(compile-time biniding)</strong> 이라고 한다. </p><p><strong>동적 바인딩</strong></p><p>객체지향 언어에서는 메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다.  </p><p>실행될 메서드를 런타임에 결정하는 방식을 <strong>동적바인딩(dynamic binding), 지연 바인딩(lazy binding)</strong> 이라고 부른다.</p><h2 id="04-동적-메서드-탐색과-다형성"><a href="#04-동적-메서드-탐색과-다형성" class="headerlink" title="04. 동적 메서드 탐색과 다형성"></a>04. 동적 메서드 탐색과 다형성</h2><p><strong>객체지향 시스템의 메서드 실행 규칙</strong></p><ul><li>메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다.</li><li>메서드를 찾미 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 이과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.</li><li>상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생히키며 탐색을 중단한다.</li></ul><p><strong>self 와 this</strong></p><blockquote><p>정적 타입 언어에 속하는 java, c++, c# 에서는 self 참조를 this 라고 부른다. 동적 타입 언어에 속하는 스몰토크, 루비에서는 셀프 참조를 나타내는 키워드로  self 를 사용한다.</p></blockquote><p>메서드 탐색은 자식 클래스에서 부모 클래스 방향으로 진행된다. 따라서 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색되기 때문에 자식 클래스에 선언된 메서드가 부모 클래스의 메서드보다 더 높은 우선 순위를 가지게 된다.</p><p><strong>동적 메서드 탐색의 두가지 원리</strong></p><ol><li>자동적인 메시지 위임<ol><li>자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속계층에 따라 부모 클래스에 처리를 위임.</li></ol></li><li>동적인 문맥<ol><li>메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다. </li></ol></li></ol><h3 id="자동적인-메시지-위임"><a href="#자동적인-메시지-위임" class="headerlink" title="자동적인 메시지 위임"></a>자동적인 메시지 위임</h3><h3 id="동적인-문맥"><a href="#동적인-문맥" class="headerlink" title="동적인 문맥"></a>동적인 문맥</h3><p><strong>self 전송을 통한 메서드 탐색</strong></p><img src="/2020/04/14/objects-12/image-20200420223146042.png" alt="image-20200420223146042" style="zoom:50%;"><p><strong>self 전송은 self 참조로부터 탐색을 다시 한다.</strong></p><img src="/2020/04/14/objects-12/image-20200420222852982.png" alt="image-20200420222852982" style="zoom:50%;"><h3 id="이해할-수-없는-메시지"><a href="#이해할-수-없는-메시지" class="headerlink" title="이해할 수 없는 메시지"></a>이해할 수 없는 메시지</h3><p><strong>정적 타입 언어와 이해할 수 없는 메시지</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lecture lecture = <span class="keyword">new</span> GradeLecture(...);</span><br><span class="line">lecture.unknownMessage(); <span class="comment">//컴파일 에러</span></span><br></pre></td></tr></table></figure><h3 id="self-대-super"><a href="#self-대-super" class="headerlink" title="self 대 super"></a>self 대 super</h3><p><strong>super 참조의 문법</strong></p><blockquote><p>대부분의 객체지향 언어는 부모 클래스에서부터 메서드 탐색이 시작하게 하는 super 참조를 위한 의사변수를 제공한다. 자바에서는 이 의사 변수를 가리키기 위해 super라는 예약어를 사용하고 c#은 base라는 예약어를 사용한다. c++의 경우 부모 클래스 이름과 범위 지정연산자인 “::” 를 조합해서 부모 클래스에서부터 메서드 탐색을 시작하게 할수 있다. </p></blockquote><p><strong>super 전송과 동적 바인딩</strong></p><blockquote><p>상속에서 super 가 컴파일 시점에 미리 결정된다고 설명했지만 super 를 런타임에 결장하는 경우도 있다. 11장에서 설명하면서 예로 들었던 스칼라의 트레이트는 super의 대상을 믹스인되는 순서에 따라 동적으로 결정한다. 따라서 사용하는 언어의 특성에 따라 컴파일 시점이 아닌 실행 시점에 super의 대상이 결정될 수도 있다는 점을 기억하기 바란다. </p></blockquote><h2 id="05-상속-대-위임"><a href="#05-상속-대-위임" class="headerlink" title="05. 상속 대 위임"></a>05. 상속 대 위임</h2><h3 id="위임와-self-참조"><a href="#위임와-self-참조" class="headerlink" title="위임와 self 참조"></a>위임와 self 참조</h3><p><strong>포워딩과 위임</strong></p><blockquote><p>객체가 다른 객체에게 요청을 처리할 때 인자로 self를 전달하지 않을 수도 있다. 이것은 요청을 전달받은 최초의 객체에 다시 메세지를 전송할 필요는 없고 단순히 코드를 재사용하고 싶은 경우라고 할 수 있다. 이처럼 처리를 요청할 때 self참조를 전달하지 않는 경우를 포워딩이라고 부른다. 이와 달리 self 참조를 전달하는 경우에는 위임이라고 부른다. 위임의 정확한 용도는 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것이다. </p></blockquote><h3 id="프로토타입-기반의-객체지향-언어"><a href="#프로토타입-기반의-객체지향-언어" class="headerlink" title="프로토타입 기반의 객체지향 언어"></a>프로토타입 기반의 객체지향 언어</h3><p>클래스 기반의 객체지향 언어들이 상속을 이요해 클래스 사이에 self 참조를 자동으로 전달하는 것처럼 프로토타입 기반의 객체지향 언어들 역시 위임을 이용해 객체 사이에 self 참조를 자동으로 전달한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lecture</span>(<span class="params">name, scores</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.scores = scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lecture.prototype.stats = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Name: "</span> + <span class="keyword">this</span>.name + <span class="string">" , Evaluation Method : "</span> + <span class="keyword">this</span>.getEvaluationMethod(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lecture.prototpye.getEvaluationMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Pass or Fail"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GradeLecture</span>(<span class="params">name,canceld, scores</span>)</span>&#123;</span><br><span class="line">  Lecture.call(<span class="keyword">this</span>, name, scores);</span><br><span class="line">  <span class="keyword">this</span>.canceld = canceld;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GradeLecture.prototype = <span class="keyword">new</span> Lecture();</span><br><span class="line">GradeLecture.prototype.constructor = GradeLecture;</span><br><span class="line"></span><br><span class="line">LgradeLecture.prototype.getEvaluationMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Grade"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체지향은 객체를 지향하는 것.</p><p>클래스는 캑체를 편리하게 정의하고 생성하기 위해 제공되는 프로그래밍 구성 요소일 뿐이며 중요한 것은 메시지와의 협력이다.</p><p>클래스 없이도 객체 사이의 협력 관계를 구축하는 것이 가능하며 상속 없이도 다형성을 구현하는 것이 가능하다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-12-다형성&quot;&gt;&lt;a href=&quot;#chapter-12-다형성&quot; class=&quot;headerlink&quot; title=&quot;chapter 12 . 다형성&quot;&gt;&lt;/a&gt;chapter 12 . 다형성&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;상속의 목적&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;상속은 타입 계층을 구조화하기 위해 사용해야한다.&lt;/p&gt;
&lt;p&gt;코드 재사용을 위해 사용해서는 안된다.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;상속을 사용하려는 목적&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;단순히 코드를 재사용하기 위해서?&lt;ol&gt;
&lt;li&gt;&lt;code&gt;상속을 사용하면 안된다.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서?&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
  </entry>
  
  <entry>
    <title>chapter-11. 합성과 유연한 설계</title>
    <link href="https://dschoi.github.io/2020/03/24/objects-11/"/>
    <id>https://dschoi.github.io/2020/03/24/objects-11/</id>
    <published>2020-03-24T07:30:43.000Z</published>
    <updated>2020-04-28T12:33:42.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-11-합성과-유연한-설계"><a href="#chapter-11-합성과-유연한-설계" class="headerlink" title="chapter 11. 합성과 유연한 설계"></a>chapter 11. 합성과 유연한 설계</h1><ul><li>상속관계 : is - a 관계</li><li>합성관계 : has -a 관계</li></ul><p>상속 : 구현은 간단하나 자식과 부모 클래스 사이의 결합도가 높아짐.</p><ul><li>클래스 사이의 정적인 관계</li></ul><p>합성: 객체의 구현이 아닌 퍼블릭 인터페이스에 의존. 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화 할 수 있다. </p><a id="more"></a><ul><li>객체 사이의 동적인 관계</li><li>변경하기 쉽고 유연한 설계를 얻을 수 있다. </li></ul><p><code>코드 재사용을 위해서는</code> 객체 합성이 클래스 상속보다 더 좋은 방법이다. </p><h2 id="01-상속을-합성으로-변경하기"><a href="#01-상속을-합성으로-변경하기" class="headerlink" title="01. 상속을 합성으로 변경하기"></a>01. 상속을 합성으로 변경하기</h2><p><strong>기존 10장 에서 보았던 코드에서 상속관계 제거 후 합성관계로 변경</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HashsTable&lt;String, String&gt; properties = <span class="keyword">new</span> HashTable&lt;&gt; ();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> properties.get(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">    properties.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>몽키 패치란 현재 실행중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것을 가리킨다. </p><p>자바는 언어 차원에서 몽키 패치를 지원하지 않기 때문에 바이트 코드를 직접 변환하거나 AOP를 이용해 몽키 패치를 구현하고 있다.</p></blockquote><h2 id="02-상속으로-인한-조합의-폭발적인-증가"><a href="#02-상속으로-인한-조합의-폭발적인-증가" class="headerlink" title="02. 상속으로 인한 조합의 폭발적인 증가"></a>02. 상속으로 인한 조합의 폭발적인 증가</h2><p><strong>추상 메서드와 훅 메서드</strong></p><blockquote><p>개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다. 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 된다. 처음에 phone 클래스에서 두 메서드를 오버라이딩한 것 역시 이 방식을 응용한 것이다. </p><p>추상메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 한다는 것이다. 대부분의 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다. 해결 방법은 메서드에 기본 구현을 제공하는 것이다. 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩 할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 훅 메서드 라고 부른다. </p></blockquote><p><img src="/2020/03/24/objects-11/image-20200407212827263.png" alt="image-20200407212827263"></p><p><strong>클래스 폭발 문제 또는 조합의 폭발 문제</strong></p><blockquote><p>상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야하는 경우</p></blockquote><h2 id="03-합성-관계로-변경하기"><a href="#03-합성-관계로-변경하기" class="headerlink" title="03. 합성 관계로 변경하기"></a>03. 합성 관계로 변경하기</h2><p>상속 관계 : 컴파일타임에 결정되고 고정됨</p><ul><li>여러 기능을 조합해야하는 설계에 상속을 이용하면 위의 경우 처럼 케이스별로 클래스를 추가해야한다.</li></ul><p>합성 관계: 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존하기에 런타임에 객체 관계를 변경할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RatePolicy ratePolicy;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Call&gt; calls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(RatePolicy ratePolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ratePolicy = ratePolicy;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Call&gt; <span class="title">getCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(calls);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateFee</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ratePolicy.caculateFee(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Phone 내부 RatePolicy 에 대한 참조자가 있다. </p><p>이것이 합성이다. </p><p><strong>합성 관계를 사용한 기분 정책의 전체적인 구조</strong></p><p><img src="/2020/03/24/objects-11/image-20200407223448312.png" alt="image-20200407223448312"></p><p><strong>기본 정책과 부가 정책 합성하기</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 요금제에 세금 정책을 조합할 경우</span></span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone(</span><br><span class="line"><span class="keyword">new</span> TaxablePolicy(<span class="number">0.05</span>), </span><br><span class="line">  <span class="keyword">new</span> RegualarPolicy(...));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 요금제에 기본 요금 할인 정책을 조합한 결과에 세금 정책을 조합할 경우</span></span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone(</span><br><span class="line"><span class="keyword">new</span> TaxablePolicy(<span class="number">0.05</span>), </span><br><span class="line">  <span class="keyword">new</span> RateDiscountablePolicy(Money.wons(<span class="number">1000</span>), </span><br><span class="line">  <span class="keyword">new</span> RegualarPolicy(...));</span><br></pre></td></tr></table></figure><p><strong>객체 합성이 클래스 상속보다 더 좋은 방법이다.</strong></p><p>코드를 재사용 하면서 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성이다. </p><p>상속은 나쁜것인가? 사용해서는 안되는것인가? </p><p>상속의 종류</p><ul><li>구현상속</li><li>인터페이스 상속</li></ul><p>이번장에서 살펴본 상속에 대한 모든 단점은 <strong>구현상속</strong>에 국한한다.</p><p><strong>인터페이스 상속</strong> 은  <strong>13장</strong> 에서 살펴볼 예정이다.</p><h2 id="04-믹스인"><a href="#04-믹스인" class="headerlink" title="04. 믹스인"></a>04. 믹스인</h2><p>믹스인(mixin) 객체를 생성할 때 코드 일부를 클래스 안에 섞어 재사용하는 기법</p><ul><li>코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지는 않는다.</li><li>코드를 다른 코드 안에 유연하게 섞어 넣을 수 있다면 믹스인이라고 부를수 있다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-11-합성과-유연한-설계&quot;&gt;&lt;a href=&quot;#chapter-11-합성과-유연한-설계&quot; class=&quot;headerlink&quot; title=&quot;chapter 11. 합성과 유연한 설계&quot;&gt;&lt;/a&gt;chapter 11. 합성과 유연한 설계&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;상속관계 : is - a 관계&lt;/li&gt;
&lt;li&gt;합성관계 : has -a 관계&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;상속 : 구현은 간단하나 자식과 부모 클래스 사이의 결합도가 높아짐.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;클래스 사이의 정적인 관계&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;합성: 객체의 구현이 아닌 퍼블릭 인터페이스에 의존. 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화 할 수 있다. &lt;/p&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
  </entry>
  
  <entry>
    <title>chapter-10. 상속과 코드 재사용</title>
    <link href="https://dschoi.github.io/2020/03/24/objects-10/"/>
    <id>https://dschoi.github.io/2020/03/24/objects-10/</id>
    <published>2020-03-24T07:30:43.000Z</published>
    <updated>2020-04-28T12:48:08.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-10-상속과-코드-재사용"><a href="#chapter-10-상속과-코드-재사용" class="headerlink" title="chapter 10. 상속과 코드 재사용"></a>chapter 10. 상속과 코드 재사용</h1><h2 id="01-상속과-중복코드"><a href="#01-상속과-중복코드" class="headerlink" title="01. 상속과 중복코드"></a>01. 상속과 중복코드</h2><h3 id="DRY-원칙"><a href="#DRY-원칙" class="headerlink" title="DRY 원칙"></a>DRY 원칙</h3><p><strong>Don’t Repet Yourself</strong></p><ul><li>반복하지 마라 </li><li>중복 여부를 판단하는 것은 변경이다. 요구사항이 변경되었을때 같이 수정되어야 하면 중복이다. </li><li>모양이 유사하다고 중복은 아니다.</li></ul><h3 id="중복과-변경"><a href="#중복과-변경" class="headerlink" title="중복과 변경"></a>중복과 변경</h3><h4 id="중복-코드-살펴보기"><a href="#중복-코드-살펴보기" class="headerlink" title="중복 코드 살펴보기"></a>중복 코드 살펴보기</h4><a id="more"></a><h4 id="중복-코드-수정하기"><a href="#중복-코드-수정하기" class="headerlink" title="중복 코드 수정하기"></a>중복 코드 수정하기</h4><h4 id="타입-코드-사용하기"><a href="#타입-코드-사용하기" class="headerlink" title="타입 코드 사용하기"></a>타입 코드 사용하기</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> PhoneType &#123;REGULAR, NIGHTLY&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Money calculateFee &#123;</span><br><span class="line">  <span class="keyword">if</span>(type === PhoneType.REGULAR) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="상속을-이용해서-중복-코드-제거하기"><a href="#상속을-이용해서-중복-코드-제거하기" class="headerlink" title="상속을 이용해서 중복 코드 제거하기"></a>상속을 이용해서 중복 코드 제거하기</h3><h3 id="강하게-결합된-Phone-과-NightlyDiscountPhone"><a href="#강하게-결합된-Phone-과-NightlyDiscountPhone" class="headerlink" title="강하게 결합된 Phone 과 NightlyDiscountPhone"></a>강하게 결합된 Phone 과 NightlyDiscountPhone</h3><p><strong>상속을 위한 경고1</strong></p><blockquote><p>자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. Super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.</p></blockquote><h2 id="02-취약한-기반-클래스-문제"><a href="#02-취약한-기반-클래스-문제" class="headerlink" title="02. 취약한 기반 클래스 문제"></a>02. 취약한 기반 클래스 문제</h2><ul><li>상속은 자식 클래스와 부모 클래스의 결합도를 높인다. </li><li>부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상 : <code>취약한 기반 클래스 문제</code></li></ul><p>객체지향의 기반은 캡슐화를 통한 변경의 통제다. </p><p>상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.</p><h3 id="불필요한-인터페이스-상속-문제"><a href="#불필요한-인터페이스-상속-문제" class="headerlink" title="불필요한 인터페이스 상속 문제"></a>불필요한 인터페이스 상속 문제</h3><p><strong>상속을 위한 경고2</strong></p><blockquote><p>상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다.</p></blockquote><h3 id="메서드-오버라이딩의-오작용-문제"><a href="#메서드-오버라이딩의-오작용-문제" class="headerlink" title="메서드 오버라이딩의 오작용 문제"></a>메서드 오버라이딩의 오작용 문제</h3><p><strong>상속을 위한 경고 3</strong></p><blockquote><p>자식 클래스가 부모 클래스의 메서들르 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될수 있다.</p></blockquote><h3 id="부모-클래스와-자식-클래스의-동시-수정-문제"><a href="#부모-클래스와-자식-클래스의-동시-수정-문제" class="headerlink" title="부모 클래스와 자식 클래스의 동시 수정 문제"></a>부모 클래스와 자식 클래스의 동시 수정 문제</h3><p><strong>상속을 위한 경고 4</strong></p><blockquote><p>클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.</p></blockquote><h2 id="03-Phone-다시-살펴보기"><a href="#03-Phone-다시-살펴보기" class="headerlink" title="03. Phone 다시 살펴보기"></a>03. Phone 다시 살펴보기</h2><h3 id="추상화에-의존하자"><a href="#추상화에-의존하자" class="headerlink" title="추상화에 의존하자"></a>추상화에 의존하자</h3><p><strong>코드 중복을 제거하기 위해 상속을 도입할 떄 따르는 두가지 원칙</strong> </p><ul><li>두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들수 있다.</li><li>부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것 보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.</li></ul><h3 id="차이를-메서드로-추출하라"><a href="#차이를-메서드로-추출하라" class="headerlink" title="차이를 메서드로 추출하라."></a>차이를 메서드로 추출하라.</h3><h3 id="중복-코드를-부모-클래스로-올려라"><a href="#중복-코드를-부모-클래스로-올려라" class="headerlink" title="중복 코드를 부모 클래스로 올려라"></a>중복 코드를 부모 클래스로 올려라</h3><p><strong>리팩토링 후 상속 계층</strong></p><p><img src="/2020/03/24/objects-10/image-20200324183934409.png" alt="image-20200324183934409"></p><h3 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다"></a>추상화가 핵심이다</h3><ul><li><strong>AbstractPhone</strong> 은 전체 통화 목록을 계산하는 방법이 바뀔 경우만 변경된다.</li><li><strong>Phone</strong> 은 일반 요금제의 통화 한건을 계산하는 방법이 바뀔 경우 변경된다.</li><li><strong>NightlyDiscountPhone</strong> 은 심야 할인 요금제의 통화 한건을 계산 하는 방법이 바뀔 경우 변경된다. </li><li>세 클래스는 각각 하나의 변경 이유만을 가진다. <strong>단일 책임 원칙</strong>을 준수하기 때문이다.</li></ul><h3 id="의도를-드러내는-이름-선택하기"><a href="#의도를-드러내는-이름-선택하기" class="headerlink" title="의도를 드러내는 이름 선택하기"></a>의도를 드러내는 이름 선택하기</h3><p><strong>Phone -&gt; RegularPhone으로 이름 변경</strong> </p><h3 id="세금-추가하기"><a href="#세금-추가하기" class="headerlink" title="세금 추가하기"></a>세금 추가하기</h3><p>객체 생성 로직의 변경에 대한 변경을 막기보다는 핵심 로직의 중복을 막아라. 핵심 로직은 한곳에 모아 놓고 조심스럽게 캡슐화 해야한다.</p><h2 id="04-차이에-의한-프로그래밍"><a href="#04-차이에-의한-프로그래밍" class="headerlink" title="04. 차이에 의한 프로그래밍"></a>04. 차이에 의한 프로그래밍</h2><p>기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 <strong>차이에 의한 프로그래밍</strong> 이라고 한다.</p><p>차이에 의한 프로그래밍의 목표</p><ul><li>중복 코드를 제거</li><li>코드 재사용</li></ul><p><strong>재사용가능한 코드란?</strong></p><ul><li>심각한 버그가 존재하지 않는 코드. </li><li>코드를 재사용 하면 코드의 품질은 유지하면서 코들르 작성하는 노력과 테스트는 줄일 수 있다. </li></ul><p><strong>중복 코드를 제거하고 재사용할수 있는 가장 유명한 방법은 상속이다.</strong> </p><ol><li>중복 코들르 하나의 클래스로 모은다.</li><li>원 클래스에서 중복 코드를 제거한 후 옮겨진 클래스를 상속 관계로 연결한다. </li></ol><p><strong>상속을 이용한 중복 코드 제거 방법</strong></p><p><img src="/2020/03/24/objects-10/image-20200324185205652.png" alt="image-20200324185205652"></p><p>상속이 코드 재사용 측면에서 매우 강력한 도구이지만 잘못 사용할 경우 돌아오는 피해 역시 크다. </p><p>상속의 오용과 남용은 애플리케이션을 이애하고 확장하기 어렵게 만든다. </p><p><code>정말로 필요한 경우에만 상속을 사용하라.</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-10-상속과-코드-재사용&quot;&gt;&lt;a href=&quot;#chapter-10-상속과-코드-재사용&quot; class=&quot;headerlink&quot; title=&quot;chapter 10. 상속과 코드 재사용&quot;&gt;&lt;/a&gt;chapter 10. 상속과 코드 재사용&lt;/h1&gt;&lt;h2 id=&quot;01-상속과-중복코드&quot;&gt;&lt;a href=&quot;#01-상속과-중복코드&quot; class=&quot;headerlink&quot; title=&quot;01. 상속과 중복코드&quot;&gt;&lt;/a&gt;01. 상속과 중복코드&lt;/h2&gt;&lt;h3 id=&quot;DRY-원칙&quot;&gt;&lt;a href=&quot;#DRY-원칙&quot; class=&quot;headerlink&quot; title=&quot;DRY 원칙&quot;&gt;&lt;/a&gt;DRY 원칙&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Don’t Repet Yourself&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;반복하지 마라 &lt;/li&gt;
&lt;li&gt;중복 여부를 판단하는 것은 변경이다. 요구사항이 변경되었을때 같이 수정되어야 하면 중복이다. &lt;/li&gt;
&lt;li&gt;모양이 유사하다고 중복은 아니다.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;중복과-변경&quot;&gt;&lt;a href=&quot;#중복과-변경&quot; class=&quot;headerlink&quot; title=&quot;중복과 변경&quot;&gt;&lt;/a&gt;중복과 변경&lt;/h3&gt;&lt;h4 id=&quot;중복-코드-살펴보기&quot;&gt;&lt;a href=&quot;#중복-코드-살펴보기&quot; class=&quot;headerlink&quot; title=&quot;중복 코드 살펴보기&quot;&gt;&lt;/a&gt;중복 코드 살펴보기&lt;/h4&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter-09. 유연한 설계</title>
    <link href="https://dschoi.github.io/2020/03/13/objects-09/"/>
    <id>https://dschoi.github.io/2020/03/13/objects-09/</id>
    <published>2020-03-13T08:26:59.000Z</published>
    <updated>2020-04-28T12:47:39.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-09-유연한-설계"><a href="#chapter-09-유연한-설계" class="headerlink" title="chapter 09. 유연한 설계"></a>chapter 09. 유연한 설계</h1><h2 id="01-개방-폐쇄-원칙"><a href="#01-개방-폐쇄-원칙" class="headerlink" title="01. 개방-폐쇄 원칙"></a>01. 개방-폐쇄 원칙</h2><p><strong>개방-폐쇄 원칙(Open-Closed Principle)</strong></p><blockquote><p>소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려있어야 하고 수정에 대해서는 닫혀 있어야한다.</p></blockquote><p>확장, 수정</p><ul><li>확장에 대해 열려 있다 : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작’을 추가해서 애플리케이션의 기능을 확장할 수 있다.<ul><li>수정에 대해 닫혀 있다 : 기존의 ‘코드’를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.</li></ul></li></ul><a id="more"></a><h3 id="컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라"><a href="#컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라" class="headerlink" title="컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라"></a>컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라</h3><p><img src="/2020/03/13/objects-09/image-20200317195733991.png" alt="image-20200317195733991"></p><p><strong>확장에는 열려있고 수정에는 열려있는 할인 정책 설계</strong></p><p><img src="/2020/03/13/objects-09/image-20200317195958014.png" alt="image-20200317195958014"></p><h3 id="추상화가-핵심이다"><a href="#추상화가-핵심이다" class="headerlink" title="추상화가 핵심이다."></a>추상화가 핵심이다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiscountPolicy</span><span class="params">(List&lt;DiscountCondition&gt; conditions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.conditions = conditions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (DiscountCondition condition : conditions) &#123;</span><br><span class="line"><span class="keyword">if</span>(condition.isSatisfiedBy(screening))&#123;</span><br><span class="line"><span class="keyword">return</span> getDiscountedFee(screening);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> screening.getMovie().getFee();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Money <span class="title">getDiscountedFee</span><span class="params">(Screening screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Money fee;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.discountPolicy = discountPolicy;</span><br><span class="line"><span class="keyword">this</span>.fee = fee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">calucateMovieFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들수 있는 것은 아니다. 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성 방향이다. <code>수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.</code></p></li><li><p>Movie는 할인 정책을 추상화한 DiscountPolicy에 대해서만 의존한다. 의존성은 변경의 영향을 의미하고 DiscountPolicy는 변하지 않는 추상화라는 사실에 주목하라. Movie는 안정된 추상화인 DiscountPolicy에 의존하기 때문에 할인 정책을 추가하기 위해 DiscountPolicy의 자식 클래스를 추가하더라도 영향을 받지 않는다. </p></li><li><p>따라서 Movie 와 DiscountPolicy 는 <code>수정에 닫혀있다.</code></p></li></ul><h2 id="02-생성-사용-분리"><a href="#02-생성-사용-분리" class="headerlink" title="02. 생성 사용 분리"></a>02. 생성 사용 분리</h2><p>*<em>예제 *</em></p><ul><li>아래 예제에서 <strong>AmountDiscountPolicy</strong>에서 <strong>PercentDiscountPolicy</strong>로 변경할수 있는 방법은 코드를 직접 수정하는 것뿐이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Money fee;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.discountPolicy = <span class="keyword">new</span> AmountDiscountPolicy(....);</span><br><span class="line"><span class="keyword">this</span>.fee = fee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">calucateMovieFee</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. </li><li>객체생성을 피할수는 없다. 하지만 부적절한 곳에서 객체를 생성하는 것이 문제다. </li></ul><p><img src="/2020/03/13/objects-09/image-20200317202647786.png" alt="image-20200317202647786"></p><p><strong>객체에 대한 생성과 사용을 분리</strong></p><blockquote><p>소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 “연결” 하는) 시작 단계와 ( 시작 단계 이후에 이어지는) 실행단계를 분리해야 한다. [Martin08]</p></blockquote><p><strong>Client 에게 생성을 위임하고 Movie는 DiscountPolicy의 사용만 해야한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">getAvatarFee</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Movie avatar = <span class="keyword">new</span> Movie(<span class="string">"아바타"</span>, </span><br><span class="line">                               Duration.ofMinutes(<span class="number">120</span>), </span><br><span class="line">                               Money.wons(<span class="number">10000</span>),</span><br><span class="line">                               <span class="keyword">new</span> AmountDiscountPolicy(...));</span><br><span class="line">      <span class="keyword">return</span> avatar.getFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/objects-09/image-20200317202949066.png" alt="image-20200317202949066"></p><h3 id="FACTORY-추가하기"><a href="#FACTORY-추가하기" class="headerlink" title="FACTORY 추가하기"></a>FACTORY 추가하기</h3><p><strong>객체 생성을 전담하는 Factory를 추가한 후의 의존성</strong></p><p><img src="/2020/03/13/objects-09/image-20200317203406593.png" alt="image-20200317203406593"></p><h3 id="순수한-가공물에게-책임-할당하기"><a href="#순수한-가공물에게-책임-할당하기" class="headerlink" title="순수한 가공물에게 책임 할당하기"></a>순수한 가공물에게 책임 할당하기</h3><p><strong>PURE FABRICATION 패턴</strong></p><p>객체지향 설계는 문제 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당한다. 하지만 만약 도메인 객체에 대한 책임을 할당할 경우  High Choosen, Low Coupling, 재사용성 등의 목적을 위반한다면 어떻게 해야 하는가?</p><p>문제 도메인 개념을 표현하지 않는 인위적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라. 이들 클래스는 문제 도메인 상에는 존재하지 않지만 순수하게 전체 설계의 품질을 높이기 위해 설계자의 임의에 따라 추가한 상상 속의 가공물이다.</p><p>Pure Fabirication은 Information Expert 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용된다. 어떤 객체가 책임을 수행하는데 필요한 많은 정보를 가졌지만 해당 책임을 할당할 경우 응집도가 낮아지고 결합도가 높아진다면 가공의 객체를 추가해서 책임을 옮기는 것을 고민하라. 순수한 가공물이라는 표현은 적절한 대안이 없을 때 사람들이 창조적인 무언가를 만들어낸다는 것을 의미하는 관용적인 표현이다.</p><h2 id="03-의존성-주입"><a href="#03-의존성-주입" class="headerlink" title="03. 의존성 주입"></a>03. 의존성 주입</h2><p><strong>의존성 주입(Dependency Injection)</strong></p><blockquote><p>사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법</p></blockquote><p><strong>의존성을 해결하는 세가지 방법</strong></p><ul><li>생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통해 의존성 해결</li><li>Setter 주입(setter injection) : 객체 생성 후 setter 메서드를 통한 의존성 해결</li><li>메서드 주입(method injection) : 메서드 실행 시 인자를 이용한 의존성 해결</li></ul><h3 id="숨겨진-의존성은-나쁘다"><a href="#숨겨진-의존성은-나쁘다" class="headerlink" title="숨겨진 의존성은 나쁘다"></a>숨겨진 의존성은 나쁘다</h3><p><strong>Service Locator 패턴</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLocator</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ServiceLocator soleInstance = <span class="keyword">new</span> ServiceLocator();</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountPolicy <span class="title">discountPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> soleInstance.discountPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">provide</span><span class="params">(DiscountPolicy discountPolicy)</span> </span>&#123;</span><br><span class="line">soleInstance.discountPolicy = discountPolicy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServiceLocator.provie(<span class="keyword">new</span> AmountDiscountPolicy(...));</span><br><span class="line">Movie avatar = <span class="keyword">new</span> Movie(<span class="string">"아바타"</span>, </span><br><span class="line">                        Duration.ofMinutes(<span class="number">120</span>), </span><br><span class="line">                        Money.wons(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">ServiceLocator.provie(<span class="keyword">new</span> PercentDiscountPolicy(...));</span><br><span class="line">Movie avatar = <span class="keyword">new</span> Movie(<span class="string">"아바타"</span>, </span><br><span class="line">                        Duration.ofMinutes(<span class="number">120</span>), </span><br><span class="line">                        Money.wons(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>Avatar Movie 생성 코드는 의존성이 감추어져 있다. </p><p>문제의 원인은 숨겨진 의존성이 캡슐화를 위반했기 때문이다. 단순히 인스턴스 변수의 가시성을 private로 선언하고 변경되는 내용을 숨겼다고해서 캡슐화가 지켜지는 것은 아니다. </p><p>캡슐화는 코드를 읽고이해하는 행위와 관련이 있다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡술화의 관점에서 훌륭한 코드다. 클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너질 것이다.</p><h2 id="04-의존성-역전-원칙"><a href="#04-의존성-역전-원칙" class="headerlink" title="04. 의존성 역전 원칙"></a>04. 의존성 역전 원칙</h2><h3 id="추상화와-의존성-역전"><a href="#추상화와-의존성-역전" class="headerlink" title="추상화와 의존성 역전"></a>추상화와 의존성 역전</h3><ol><li>상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.</li><li>추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.</li></ol><h3 id="의존성-역전-원칙과-패키지"><a href="#의존성-역전-원칙과-패키지" class="headerlink" title="의존성 역전 원칙과 패키지"></a>의존성 역전 원칙과 패키지</h3><p><img src="/2020/03/13/objects-09/image-20200324162319854.png" alt="image-20200324162319854"></p><p><img src="/2020/03/13/objects-09/image-20200324162332623.png" alt="image-20200324162332623"></p><h2 id="05-유연성에-대한-조언"><a href="#05-유연성에-대한-조언" class="headerlink" title="05. 유연성에 대한 조언"></a>05. 유연성에 대한 조언</h2><h3 id="유연한-설계는-유연성이-필요할-때만-옳다"><a href="#유연한-설계는-유연성이-필요할-때만-옳다" class="headerlink" title="유연한 설계는 유연성이 필요할 때만 옳다"></a>유연한 설계는 유연성이 필요할 때만 옳다</h3><blockquote><p>유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일 타임 의존성의 차이를 인식하고 동일한 컴파일 타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드를 가지는 설계를 의미한다.</p></blockquote><ul><li>설계의 미덕 = <code>단순함</code>,<code>명확함</code></li><li>미래의 변경이 일어날지도 모른다는 막연한 불안감을 불필요하게 복잡한 설계를 낳음</li></ul><blockquote><p>아직 일어나지 않는 변경은 변경이 아니다.</p></blockquote><ul><li>유연함은 단순성과 명확성의 희생 위에서 자라남</li><li>불필요한 유연성은 불필요한 복잡성을 낳음</li><li>유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있음</li><li>프로그램(텍스트 공간에 흩뿌려진) 과 진행 과정 사이를 가능한 한 일치시켜야 함</li></ul><h3 id="협력과-책임이-중요하다"><a href="#협력과-책임이-중요하다" class="headerlink" title="협력과 책임이 중요하다"></a>협력과 책임이 중요하다</h3><ul><li>객체의 협력과 책임이 중요</li><li>설계를 유연하게 만들기 위헤서는 <code>역할</code>, <code>책임</code>, <code>협력</code>에 초점을 맞춰야함</li><li>객체를 생성하는 방법에 대한 결정은 모든 책임이 자리 잡은 후 마지막 시점에 내리는 것이 적절</li><li>객체가 무엇이 되고 싶은지를 알게 될 때까지 객체들은 어떻게 인스턴스화 할 것인지에 대해 전혀 신경 쓰지 않음</li><li>너무 일찍 결정하는 것은 비생산적임</li></ul><blockquote><p>역할, 책임, 협력에 먼저 집중하라.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-09-유연한-설계&quot;&gt;&lt;a href=&quot;#chapter-09-유연한-설계&quot; class=&quot;headerlink&quot; title=&quot;chapter 09. 유연한 설계&quot;&gt;&lt;/a&gt;chapter 09. 유연한 설계&lt;/h1&gt;&lt;h2 id=&quot;01-개방-폐쇄-원칙&quot;&gt;&lt;a href=&quot;#01-개방-폐쇄-원칙&quot; class=&quot;headerlink&quot; title=&quot;01. 개방-폐쇄 원칙&quot;&gt;&lt;/a&gt;01. 개방-폐쇄 원칙&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;개방-폐쇄 원칙(Open-Closed Principle)&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려있어야 하고 수정에 대해서는 닫혀 있어야한다.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;확장, 수정&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;확장에 대해 열려 있다 : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작’을 추가해서 애플리케이션의 기능을 확장할 수 있다.&lt;ul&gt;
&lt;li&gt;수정에 대해 닫혀 있다 : 기존의 ‘코드’를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 08. 의존성 관리하기</title>
    <link href="https://dschoi.github.io/2020/03/10/objects-08/"/>
    <id>https://dschoi.github.io/2020/03/10/objects-08/</id>
    <published>2020-03-10T14:57:34.000Z</published>
    <updated>2020-04-28T12:47:36.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-08-의존성-관리하기"><a href="#chapter-08-의존성-관리하기" class="headerlink" title="chapter 08. 의존성 관리하기"></a>chapter 08. 의존성 관리하기</h1><h2 id="01-의존성-이해하기"><a href="#01-의존성-이해하기" class="headerlink" title="01. 의존성 이해하기"></a>01. 의존성 이해하기</h2><p>잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.</p><p>작고 응집도 높은 객체란? 책임의 초점이 명확하고 한가지 일만 잘하는 객체를 의미.</p><p>협력은 필수적이다. 하지만 과도한 협력은 설계를 곤경에 빠뜨린다. </p><a id="more"></a><p>객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다. 이런 관점에서 </p><p><strong>객체지향 설계란?</strong></p><blockquote><p> 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라 할수 있다.</p></blockquote><h3 id="변경과-의존성"><a href="#변경과-의존성" class="headerlink" title="변경과 의존성"></a>변경과 의존성</h3><p>어떤 객체가 협력하기 위해 다른 객체를 필요로 할때 두 객체 사이에 의존성이 존재하게 된다.</p><p>의존성은 실행시점과 구현 시점에 다른 의미를 가진다.</p><ul><li>실행시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.</li><li>구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class PeriodCondition implements DiscountCondition &#123;</span><br><span class="line"><span class="keyword">private</span> DayOfWeek dayOfWeek;</span><br><span class="line">  <span class="keyword">private</span> LocalTime startTime;</span><br><span class="line">  <span class="keyword">private</span> LocalTime endTime;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/03/10/objects-08/image-20200310225940196.png" alt="image-20200310225940196" style="zoom:50%;"><hr><p>두 요소 사이의 의존성은 의존되는 요소가 변경될때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.</p><h3 id="의존성-전이"><a href="#의존성-전이" class="headerlink" title="의존성 전이"></a>의존성 전이</h3><ul><li>의존성 전이가 의미하는것은 peridoCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것.</li></ul><img src="/2020/03/10/objects-08/image-20200310230131152.png" alt="image-20200310230131152" style="zoom:50%;"><p><strong>의존성의 종류</strong></p><ul><li>직접 의존성 : 한 요소가 다른 요소에 직접 의존하는 경우를 가르킨다.<ul><li>ex ) periodCondition 이 screening에 의존하는 경우</li></ul></li><li>간접 의존성  : 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가르킨다.</li></ul><h3 id="런타임-의존성과-컴파일타임-의존성"><a href="#런타임-의존성과-컴파일타임-의존성" class="headerlink" title="런타임 의존성과 컴파일타임 의존성"></a>런타임 의존성과 컴파일타임 의존성</h3><ul><li>런타임 의존성<ul><li>애플리케이션이 실행되는 시점</li></ul></li><li>컴파일타임 의존성<ul><li>작성된 코드를 컴파일 하는 시점을 가르키지만 문맥에 따라서는 코드 자체를 가르키기도 한다.</li></ul></li></ul><img src="/2020/03/10/objects-08/image-20200310230748584.png" alt="image-20200310230748584" style="zoom:50%;"><img src="/2020/03/10/objects-08/image-20200310230906091.png" alt="image-20200310230906091" style="zoom:50%;"><blockquote><p>객체지향 프로그램의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다. 코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다. 그러나 프로그램의 실행 시점 구조는 협력하는 객체에 따라서 달라질 수 있다. 즉, 두 구조는 전혀 다른 별개의 독립성을 갖는다. 하나로부터 다른 하나를 이해하려는 것은 생태계의 동적인 성질을 식물과 동물과 같은 정적 분류 구조를 바탕으로 이해하려 하는 것과 똑같다. 컴파일 시점의 구조와 실행 시점 구조 사이에 차이가 있기 때문에 코드 자체가 시스템의 동작 방법을 모두 보여줄수 없다. 시스템의 실행 시점 구조는 언어가 아닌 설계자가 만든 타입들 간의 관련성으로 만들어진다. 그러므로 객체와 타입 간의 관계를 잘 정의해야 좋은 실행 구조를 만들어 낼수 있다.</p></blockquote><h3 id="컨텍스트-독립성"><a href="#컨텍스트-독립성" class="headerlink" title="컨텍스트 독립성"></a>컨텍스트 독립성</h3><blockquote><p>클래스가 사용될 특정한 문맥에 대해 최소한의 가정으로만 이루어 져 있다면 다른 문맥에서 재사용하기 수월해진다. </p><p>설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야한다.</p></blockquote><h3 id="의존성-해결하기"><a href="#의존성-해결하기" class="headerlink" title="의존성 해결하기"></a>의존성 해결하기</h3><p><strong>의존성 해결</strong></p><p>컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것</p><p><strong>의존성 해결을 위한 방법 세가지</strong></p><ul><li>객체를 생성하는 시점에 생성자를 통해 의존성 해결</li><li>객체 생성 후 setter 메서드를 통해 의존성 해결</li><li>메서드 실행 시 인자를 이용해 의존성 해결</li></ul><h2 id="02-유연한-설계"><a href="#02-유연한-설계" class="headerlink" title="02. 유연한 설계"></a>02. 유연한 설계</h2><h3 id="의존성과-결합도"><a href="#의존성과-결합도" class="headerlink" title="의존성과 결합도"></a>의존성과 결합도</h3><h3 id="지식이-결합을-낳는다"><a href="#지식이-결합을-낳는다" class="headerlink" title="지식이 결합을 낳는다"></a>지식이 결합을 낳는다</h3><p>결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대하 알고 있는 정보의 양으로 결정된다. 한 요소가 다른 요소에 대하 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다. </p><p><strong>더 많이 알수록 더 많이 결합된다.</strong></p><p>더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다.</p><h3 id="추상화에-의존하라"><a href="#추상화에-의존하라" class="headerlink" title="추상화에 의존하라"></a>추상화에 의존하라</h3><p><strong>추상화란?</strong></p><p>어떤 양상, 세부사항 , 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다. </p><p><strong>결합도가 큰 순서</strong></p><ol><li>구체 클래스 의존성</li><li>추상 클래스 의존성</li><li>인터페이스 의존성</li></ol><p><strong>결합도를 느슨하게 만들기 위해서는?</strong></p><p>구체적인 클래스보다는 추상 클래스에, 추상 클래스 보다는 인터페이스에 의존하도록 만드는 것이 효과적이다.</p><p>의존하는 대상이 추상적일 수록 결합도는 낮아진다.</p><h3 id="명시적인-의존성"><a href="#명시적인-의존성" class="headerlink" title="명시적인 의존성"></a>명시적인 의존성</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, Duration runningTime, Money fee)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">this</span>.discountPolity = <span class="keyword">new</span> AmountDiscountPolicy(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>숨겨진 의존성(hidden dependency)</strong> </p><p><img src="/2020/03/10/objects-08/image-20200310232133291.png" alt="image-20200310232133291"></p><p><strong>명시적 의존성(explicit dependency)</strong></p><p>명시적으로 퍼블릭 인터페이스에 노출시킴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">this</span>.discountPolity = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다. 코드 수정은 언제나 버거 발생가능성을 내포한다. 의존성을 명시적으로 드러내면 코드를 직접 수정해야하는 위험을 피할 수 있다.</p><p>의존성은 명시적으로 표현되야 한다. 의존성을 구현 내부에 숨겨두지 마라. 명시적은 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.</p><h3 id="new-는-해롭다"><a href="#new-는-해롭다" class="headerlink" title="new 는 해롭다"></a>new 는 해롭다</h3><p><strong>결합도 측면에서 new 가 해로운 이유 두가지</strong></p><ul><li>new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new 를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.</li><li>new 연산자는 생성하려는 구체 클래스뿐 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new 를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">this</span>.discountPolity = <span class="keyword">new</span> AmountDiscountPolicy(Money.wons(<span class="number">800</span>),</span><br><span class="line">                                 <span class="keyword">new</span> SequenceCondition(<span class="number">1</span>), </span><br><span class="line">                                 <span class="keyword">new</span> SequenceCondition(<span class="number">10</span>), </span><br><span class="line">                                 <span class="keyword">new</span> PriodCondition(....), </span><br><span class="line">                                 <span class="keyword">new</span> PriodCondition(....)</span><br><span class="line">                                     );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/10/objects-08/image-20200310233738768.png" alt="image-20200310233738768"></p><h3 id="표준-클래스에-대한-의존은-해롭지-않다"><a href="#표준-클래스에-대한-의존은-해롭지-않다" class="headerlink" title="표준 클래스에 대한 의존은 해롭지 않다"></a>표준 클래스에 대한 의존은 해롭지 않다</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>의존성에 의한 영향이 적은 경우데도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchConditions</span><span class="params">(List&lt;DiscountCondition&gt; conditions)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.conditions = conditions;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조합-가능한-행동"><a href="#조합-가능한-행동" class="headerlink" title="조합 가능한 행동"></a>조합 가능한 행동</h3><p>유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다. </p><p>훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다. 그리고 지금까지 설명한 것처럼 이런 설계를 창조하는데 있어서의 핵심은 의존성을 관리하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-08-의존성-관리하기&quot;&gt;&lt;a href=&quot;#chapter-08-의존성-관리하기&quot; class=&quot;headerlink&quot; title=&quot;chapter 08. 의존성 관리하기&quot;&gt;&lt;/a&gt;chapter 08. 의존성 관리하기&lt;/h1&gt;&lt;h2 id=&quot;01-의존성-이해하기&quot;&gt;&lt;a href=&quot;#01-의존성-이해하기&quot; class=&quot;headerlink&quot; title=&quot;01. 의존성 이해하기&quot;&gt;&lt;/a&gt;01. 의존성 이해하기&lt;/h2&gt;&lt;p&gt;잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.&lt;/p&gt;&lt;p&gt;작고 응집도 높은 객체란? 책임의 초점이 명확하고 한가지 일만 잘하는 객체를 의미.&lt;/p&gt;&lt;p&gt;협력은 필수적이다. 하지만 과도한 협력은 설계를 곤경에 빠뜨린다. &lt;/p&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 07. 객체 분해</title>
    <link href="https://dschoi.github.io/2020/03/03/objects-07/"/>
    <id>https://dschoi.github.io/2020/03/03/objects-07/</id>
    <published>2020-03-03T09:26:34.000Z</published>
    <updated>2020-04-28T12:47:32.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-07-객체-분해"><a href="#chapter-07-객체-분해" class="headerlink" title="chapter 07. 객체 분해"></a>chapter 07. 객체 분해</h1><p><strong>인지과부하(cognitive overload)</strong></p><blockquote><p>문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하여 문제 해결 능력이 급격히 떨어지는 현상</p></blockquote><p><strong>추상화</strong></p><blockquote><p>불필요한 정보를 제거학 현재의 문제 해결에 필요한 핵심만 남기는 작업</p></blockquote><p><strong>분해</strong></p><blockquote><p>큰 문제를 해결 가능한 작은 문제로 나누는 작업</p></blockquote><a id="more"></a><h2 id="01-프로시저-추상화와-데이터-추상화"><a href="#01-프로시저-추상화와-데이터-추상화" class="headerlink" title="01. 프로시저 추상화와 데이터 추상화"></a>01. 프로시저 추상화와 데이터 추상화</h2><p><strong>프로시저 추상화</strong></p><blockquote><p>소프트웨어가 무엇을 해야 하는 지를 추상화</p></blockquote><p><strong>데이터 추상화</strong></p><blockquote><p>소프트웨어가 무엇을 알아야 하는지를 추상화</p></blockquote><p><strong>시스템 분해방법</strong></p><ul><li>프로시저 중심의 시스템 분해 -&gt; 기능 분해 (알고리즘 분해)</li><li>데이터 추상화 중심으로 시스템 분해 <ul><li>데이터를 중심으로 타입을 추상화 -&gt; 추상 데이터 타입</li><li>데이터를 중심으로 포로시저를 추상화 -&gt; 객체지향</li></ul></li></ul><h2 id="02-프로시저-추상화와-기능-분해"><a href="#02-프로시저-추상화와-기능-분해" class="headerlink" title="02. 프로시저 추상화와 기능 분해"></a>02. 프로시저 추상화와 기능 분해</h2><h3 id="메인-함수로서의-시스템"><a href="#메인-함수로서의-시스템" class="headerlink" title="메인 함수로서의 시스템"></a>메인 함수로서의 시스템</h3><p><strong>알고리즘 분해 - 기능 분해</strong></p><p>기능 중심의 데이터 분해 </p><p><strong>프로시저</strong></p><ul><li>반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법</li><li>내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용가능하기에 <strong>추상화</strong>라고 부른다.</li><li>정보은닉의 가능성은 제공하지만 프로시저만으로는 효과적인 정보은닉 체계 구축은 <strong>어렵다.</strong></li></ul><p><strong>전통적인 기능 분해 방법 - 하향식 접근법(top-down approach)</strong></p><ul><li>시스템을 구성하는 최상위 기능을 정의하고 , 최상위 기능을 작은 단계의 하위 기능으로 분해하는 방법</li></ul><h3 id="급여-관리-시스템"><a href="#급여-관리-시스템" class="headerlink" title="급여 관리 시스템"></a>급여 관리 시스템</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">직원의 급여를 계산한다.</span><br><span class="line">사용자로부터 소득세율을 입력받는다.</span><br><span class="line">&quot;세율을 입력하세요: &quot; 라는 문장을 화면에 출력한다.</span><br><span class="line">키보드를 통해 세율을 입력받는다.</span><br><span class="line">  직원의 급여를 계산한다.</span><br><span class="line">  전역 변수에 저장된 직원의 기본급 정보를 얻는다.</span><br><span class="line">  급여를 계산한다.</span><br><span class="line"> 양식에 맞게 결과를 출력한다.</span><br><span class="line"> &quot;이름: &#123;직원명&#125;, 급여: &#123;계산된 금액&#125;&quot; 형식에 따라 출력 문자열을 생성한다.</span><br></pre></td></tr></table></figure><img src="/2020/03/03/objects-07/image-20200304084414089.png" alt="image-20200304084414089" style="zoom:50%;"><h3 id="급여-관리-시스템-구현"><a href="#급여-관리-시스템-구현" class="headerlink" title="급여 관리 시스템 구현"></a>급여 관리 시스템 구현</h3><img src="/2020/03/03/objects-07/image-20200304084436480.png" alt="image-20200304084436480" style="zoom:50%;"><h3 id="하향식-기능-분해의-문제점"><a href="#하향식-기능-분해의-문제점" class="headerlink" title="하향식 기능 분해의 문제점"></a>하향식 기능 분해의 문제점</h3><ul><li>시스템은 하나의 메인 함수로 구성돼 있지 않다.</li><li>기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.</li><li>비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.</li><li>하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</li><li>데이터 형식이 변경될 경우 파급효과를 예측할수 없다.</li></ul><h4 id="하나의-메인-함수라는-비현실적인-아이디어"><a href="#하나의-메인-함수라는-비현실적인-아이디어" class="headerlink" title="하나의 메인 함수라는 비현실적인 아이디어"></a><strong>하나의 메인 함수라는 비현실적인 아이디어</strong></h4><p>어떤 시스템도 최초에 릴리즈됐던 당시의 모습을 그대로 유지하지 않는다. </p><p>시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.</p><p>대부분의 시스템에서는 하나의 메인 기능이란 개념은 존재하지 않는다. </p><p>하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다. 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성된다. </p><h4 id="메인-함수의-빈번한-재설계"><a href="#메인-함수의-빈번한-재설계" class="headerlink" title="메인 함수의 빈번한 재설계"></a><strong>메인 함수의 빈번한 재설계</strong></h4><h4 id="비즈니스-로직과-사용자-인터페이스의-결합"><a href="#비즈니스-로직과-사용자-인터페이스의-결합" class="headerlink" title="비즈니스 로직과 사용자 인터페이스의 결합"></a><strong>비즈니스 로직과 사용자 인터페이스의 결합</strong></h4><p>하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. </p><p>결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다. </p><p>비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다른데 탑다운 방식에서는 동일하게 두고 사용하고 있다. </p><p>하향식 접근법은 기능을 분해하는 과정에서 사용자 인터페이스의 관심사와 비즈니스 로직의 관심사를 동시에 고려하도록 강요하기 때문에 “관심사의 분리” 라른 아키텍처 설계의 목적을 달성하기 어렵다.</p><h4 id="성급하게-결정된-실행-순서"><a href="#성급하게-결정된-실행-순서" class="headerlink" title="성급하게 결정된 실행 순서"></a><strong>성급하게 결정된 실행 순서</strong></h4><p>하향식 설계와 관련된 모든 문제의 원인은 <strong>결합도</strong></p><p>함수는 상위 함수가 강요하는 문맥에 강하게 결합되어짐. </p><p>가장 큰 문제는 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합된다는 점</p><h3 id="언제-하향식-분해가-유용한가"><a href="#언제-하향식-분해가-유용한가" class="headerlink" title="언제 하향식 분해가 유용한가?"></a>언제 하향식 분해가 유용한가?</h3><p>설계가 어느정도 안정화 된 후 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이.</p><h2 id="03-모듈"><a href="#03-모듈" class="headerlink" title="03. 모듈"></a>03. 모듈</h2><h3 id="정보-은닉과-모듈"><a href="#정보-은닉과-모듈" class="headerlink" title="정보 은닉과 모듈"></a>정보 은닉과 모듈</h3><p><strong>정보은닉</strong></p><blockquote><p>시스템을 모듈 단위로 분해하기 위한 기본원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 하는 것 </p></blockquote><p>시스템을 모듈로 분할하는 원칙 - 데이비드 파나스 </p><blockquote><p>모듈은 서브 프로그램이라기 보다는 책임의 할당이다. </p><p>모듈화는 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정들을 포함한다. 분할된 모듈은 다른 모듈에 대해 감춰야 하는 설계 결정에 따라 특징지어진다. 해당 모듈내부의 작업을 가능한 한 적게 노출하는 인터페이스 또는 정의를 선택한다. </p></blockquote><p><strong>모듈은</strong></p><ul><li>변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다. </li></ul><p><strong>모듈이 감추어야 할 비밀 두가지</strong></p><ol><li>복잡성 <ul><li>모듈이 너무 복잡한 경우 사용하기 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.</li></ul></li><li>변경가능성<ul><li>벽녕 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 <code>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.</code></li></ul></li></ol><h3 id="모듈의-장점과-한계"><a href="#모듈의-장점과-한계" class="headerlink" title="모듈의 장점과 한계"></a>모듈의 장점과 한계</h3><p><strong>모듈의 장점</strong> </p><ol><li>모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.<ul><li>모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다. </li></ul></li><li>비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.<ul><li>모듈은 비즈니스 로직과 관련된 관심사만 담당하며. 사용자 인터페이스가 변경되더라도 비즈니스 로직은 변경되지 않는다.</li></ul></li><li>전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.<ul><li>변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있다. </li></ul></li></ol><p>모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.</p><p>메인 함수를 정의하고 필요에 따라 더 세부적인 함수로 분해하는 하향힛 기능 분해와 달리 모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조적하는데 필요한 함수를 결정한다.</p><p><strong>모듈의 가장 큰 단점</strong>은 <code>인스턴스의 개념을 제공하지 않는다는 점</code>.</p><h2 id="04-데이터-추상화와-추상-데이터-타입"><a href="#04-데이터-추상화와-추상-데이터-타입" class="headerlink" title="04. 데이터 추상화와 추상 데이터 타입"></a>04. 데이터 추상화와 추상 데이터 타입</h2><h3 id="추상-데이터-타입"><a href="#추상-데이터-타입" class="headerlink" title="추상 데이터 타입"></a>추상 데이터 타입</h3><p>추상데이터 타입을 구현하기 위한 프로그래밍 언어의 지원 사항</p><ul><li><p>타입의 정이를 선언할 수 있어야한다.</p></li><li><p>타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션을정의할 수 있어야 한다.</p></li><li><p>제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야한다.</p></li><li><p>타입에 대해 여러개의 인스턴스를 생성할 수 잇어야 한다. </p></li></ul><h2 id="05-클래스"><a href="#05-클래스" class="headerlink" title="05.클래스"></a>05.클래스</h2><h3 id="클래스는-추상-데이터-타입인가"><a href="#클래스는-추상-데이터-타입인가" class="headerlink" title="클래스는 추상 데이터 타입인가?"></a>클래스는 추상 데이터 타입인가?</h3><p><strong>클래스와 추상데이터 타입의 차이</strong></p><p>클래스는 상속과 다형성을 지원하는데 비해 추상 데이터 타입은 지원하지 못한다 는 점</p><h3 id="변경을-기준으로-선택하라"><a href="#변경을-기준으로-선택하라" class="headerlink" title="변경을 기준으로 선택하라"></a>변경을 기준으로 선택하라</h3><p>객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.</p><p>클라이언트가 객체의 타입을 확인 한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택하도록 한다.</p><p><strong>개방폐쇄원칙</strong></p><blockquote><p>기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성</p></blockquote><p>새로운 타입을 빈번하게 추가해야한다면 -&gt; 객체지향의 클래스가 유용</p><p>새로운 오퍼레이션을 빈번하게 추가해야한다면 -&gt; 추상 데이터 타입</p><h3 id="협력이-중요하다"><a href="#협력이-중요하다" class="headerlink" title="협력이 중요하다"></a>협력이 중요하다</h3><p>객체지향에서 중요한 것은 역할, 책임, 협력이다. </p><p>협력이라는 문맥을 고려하지 않고  객체를 고립시킨 ㅂ 계층과 다형성은 ㅎ채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 옳은 방법이 아니다. </p><p>객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하고 , 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화 하라. 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되서는 안된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-07-객체-분해&quot;&gt;&lt;a href=&quot;#chapter-07-객체-분해&quot; class=&quot;headerlink&quot; title=&quot;chapter 07. 객체 분해&quot;&gt;&lt;/a&gt;chapter 07. 객체 분해&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;인지과부하(cognitive overload)&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하여 문제 해결 능력이 급격히 떨어지는 현상&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;불필요한 정보를 제거학 현재의 문제 해결에 필요한 핵심만 남기는 작업&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;분해&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;큰 문제를 해결 가능한 작은 문제로 나누는 작업&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 06. 메시지와 인터페이스</title>
    <link href="https://dschoi.github.io/2020/02/18/objects-06/"/>
    <id>https://dschoi.github.io/2020/02/18/objects-06/</id>
    <published>2020-02-18T13:26:34.000Z</published>
    <updated>2020-04-28T12:47:28.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-06-메시지와-인터페이스"><a href="#chapter-06-메시지와-인터페이스" class="headerlink" title="chapter 06. 메시지와 인터페이스"></a>chapter 06. 메시지와 인터페이스</h1><p>객체지향 프로그래밍에 대한 가장 흔한 오해 </p><ul><li>애플리케이션은 클래스의 집합으로 구성된다. </li></ul><blockquote><p><code>애플리케이션</code>은 클래스로 구성되지만<code>메시지를 통해 정의</code>된다.</p></blockquote><h2 id="01-협력과-메시지"><a href="#01-협력과-메시지" class="headerlink" title="01. 협력과 메시지"></a>01. 협력과 메시지</h2><h3 id="클라이언트-서버-모델"><a href="#클라이언트-서버-모델" class="headerlink" title="클라이언트-서버 모델"></a>클라이언트-서버 모델</h3><ul><li>협력안에서 메시지를 전송하는 객체를 <strong>클라이언트</strong></li><li>메세지를 수신하는 객체를 <strong>서버</strong></li></ul><a id="more"></a><p><strong>클라이언트와 서버 역할을 동시에 수행하는 Movie</strong></p><img src="/2020/02/18/objects-06/image-20200223211641253.png" alt="image-20200223211641253" style="zoom:50%;"><p>객체가 독립적으로 수향할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것.</p><p>두 객체 사이의 협력을 가능하게 해주는 매개채가 바로 메시지.</p><h3 id="메시지와-메시지-전송"><a href="#메시지와-메시지-전송" class="headerlink" title="메시지와 메시지 전송"></a>메시지와 메시지 전송</h3><p><strong>메세지</strong></p><p>객체들이 협력하기 위해 사용할 수 있는 유일한 교통 수단.</p><ul><li>오퍼레이션 명 + 인자로 구성</li></ul><p><strong>메시지 전송 or 메시지 패싱</strong></p><p>한 객체가 다른 객체에게 도움을 요청하는 것</p><p><strong>메시지 전송자</strong> - 클라이언트</p><p>메시지를 전송하는 객체</p><p><strong>메시지 수신자</strong> - 서버</p><p>메시지를 수신하는 객체</p><p>condition : 수신자</p><p>isSatisfiedBy : 오퍼레이션 명</p><p>screening : 인자</p><p>Ex) condition.isSatisfiedBy(screening);</p><h3 id="메시지와-메서드"><a href="#메시지와-메서드" class="headerlink" title="메시지와 메서드"></a>메시지와 메서드</h3><p><strong>메서드</strong></p><p>메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저</p><p>ex) 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.</p><p>메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇고 가는 끈을 통해 연결된다. 실행 시점에 메시지와 메서드를 바인딩 하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.</p><h3 id="퍼블릭-인터페이스와-오퍼레이션"><a href="#퍼블릭-인터페이스와-오퍼레이션" class="headerlink" title="퍼블릭 인터페이스와 오퍼레이션"></a>퍼블릭 인터페이스와 오퍼레이션</h3><p><strong>퍼블릭 인터페이스</strong></p><p>객체가 의사소통을 위해 외부에 공개하는 메시지의 집합</p><p><strong>오퍼레이션</strong></p><p>퍼블릭 인터페이스에 포함된 메시지</p><p><strong>메서드</strong></p><p>메시지를 수신했을 때 실제로 실행되는 코드</p><blockquote><p>인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다. 반면 UML 의 메서드는 오퍼레이션을 구현한 것이다. </p></blockquote><img src="/2020/02/18/objects-06/image-20200223212722901.png" alt="image-20200223212722901" style="zoom:50%;"><h3 id="시그니처"><a href="#시그니처" class="headerlink" title="시그니처"></a>시그니처</h3><p><strong>시그니처</strong></p><p>오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것</p><p><strong>오퍼레이션</strong></p><p>실행 코드 없이 시그니처만 정의한 것</p><p><strong>메서드</strong></p><p>시그니처에 구현을 더한 것</p><hr><blockquote><p>오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행 되는 것 </p></blockquote><hr><p><strong>용어 정리</strong></p><ul><li>메시지 : 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘</li><li>오퍼레이션 : 객체가 다른 객체에게 제공하는 추상적인 서비스.</li><li>메서드 : 메시지에 응답하기 위해 실행되는 코드 블록. 오퍼레이션의 구현. 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다. </li><li>퍼블릭 인터페이스: 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.</li><li>시그니처: 오퍼레이션이나 메서드의 명세를 나타낸 것. 이름과 인자의 목록을 포함.</li></ul><h2 id="02-인터페이스와-설계-품질"><a href="#02-인터페이스와-설계-품질" class="headerlink" title="02. 인터페이스와 설계 품질"></a>02. 인터페이스와 설계 품질</h2><p><strong>좋은 인터페이스의 조건</strong></p><ul><li>최소한의 인터페이스</li><li>추상적인 인터페이스</li></ul><h3 id="디미터-법칙"><a href="#디미터-법칙" class="headerlink" title="디미터 법칙"></a>디미터 법칙</h3><blockquote><p>객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.</p><p>“낯선 자에게 말하지 말라” 또는 “오직 인접한 이웃하고만 말하라.”</p></blockquote><p><strong>디미터 법칙을 따르기 위한 조건</strong> </p><ul><li>this 객체</li><li>메서드의 매개변수</li><li>this 의 속성</li><li>this의 속성인 컬렉션의 요소</li><li>메서드 내에서 생성된 지역 객체</li></ul><p><strong>디미터 법칙과 캡슐화</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions(); <span class="comment">//디미터 법칙을 위반하는 전형적인 코드</span></span><br><span class="line"><span class="comment">// 기차 충돌(train wreck)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  screening.calculateFee(audienceCount); <span class="comment">// 디미터 법칙을 따르도록 코드를 개선하여 메시지 수신자의 내부 구조에 관해 묻지 않게 된다.</span></span><br></pre></td></tr></table></figure><h3 id="묻지말고-시켜라"><a href="#묻지말고-시켜라" class="headerlink" title="묻지말고 시켜라"></a>묻지말고 시켜라</h3><p>훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 것을 강조한다.</p><blockquote><p> 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.</p></blockquote><ul><li>내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해 보라. </li><li>내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 해당 객체가 책임져야하는 행동이 외부로 누수된 것이다.</li><li>상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라. </li><li></li></ul><h3 id="의도를-드러내는-인터페이스"><a href="#의도를-드러내는-인터페이스" class="headerlink" title="의도를 드러내는 인터페이스"></a>의도를 드러내는 인터페이스</h3><p><strong>켄트벡의 메서드를 명명하는 두가지 방법</strong> </p><ol><li>메서드가 작업을 어떻게  수행하는지를 나타내도록 이름 짓는 것</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfideByPeriod</span><span class="params">(Screening screening)</span> </span>&#123;... &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 스타일이 좋지 않은 이유 두가지 </p><pre><code>1. 메서드에 대해 제대로 커뮤니케이션 하지 못한다. 2. 메서드 수준에서 캡슐화를 위반한다</code></pre><ol start="2"><li>‘어떻게’ 가 아니라 ‘무엇’을 하는지를 드러내는 것</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;... &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 <code>의도를 드러내는 선택자</code> 라고 한다. </p><p><strong>메서드에 의도를 드러낼수 있는 이름을 붙이기 위한 방법 - 켄트벡</strong></p><blockquote><p>매우 다른 두번째 구현을 상항하라. 그러고 해당 메서드에 동일한 이름을 붙인다고 상상해라. 그렇게 하면 아마도 그 순간에 여러분이 할 수 잇는 가장 추상적인 이름을 메서드에 붙일 것이다.</p></blockquote><p>의도를 드러내는 선택자를 인터페이스 레벨로 확장한 의도를 드러내는 인터페이스를 제시함. - 에릭에반스</p><p><code>객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.</code></p><h3 id="함께-모으기"><a href="#함께-모으기" class="headerlink" title="함께 모으기"></a>함께 모으기</h3><p><strong>디미터 법칙을 위반하는 티켓 판매 도메인</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Theater</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TicketSeller ticketSeller;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Theater</span><span class="params">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ticketSeller = ticketSeller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Audience audience)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class="line">Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class="line">audience.getBag().setTicket(ticket);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Ticket ticket =ticketSeller.getTicketOffice().getTicket();</span><br><span class="line">audience.getBag().minusAmount(ticket.getFee());</span><br><span class="line">ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class="line">audience.getBag().setTicket(ticket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-원칙의-함정"><a href="#03-원칙의-함정" class="headerlink" title="03. 원칙의 함정"></a>03. 원칙의 함정</h2><h3 id="디미터-법칙은-하나의-도트-를-강제하는-규칙이-아닌다"><a href="#디미터-법칙은-하나의-도트-를-강제하는-규칙이-아닌다" class="headerlink" title="디미터 법칙은 하나의 도트(.) 를 강제하는 규칙이 아닌다."></a>디미터 법칙은 하나의 도트(.) 를 강제하는 규칙이 아닌다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">9</span>).filter(x -&gt; x &gt; <span class="number">10</span>).distinct().count();</span><br></pre></td></tr></table></figure><p>디미터의 법칙  “오직 하나의 도트만을 사용해라” 라는 관점에서 위의 코드는 위반되었다고 볼수 있다. </p><p>하지만. of, filter, distinct 메서드는 intStream instance를 반환하기에 디미터 법칙을 위반하지 않는다.</p><p>디미터 법칙은 <code>결합도</code> 와 관련된 것이며 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정한다. </p><p>여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가? 라는 질문을 하기를 바란다.</p><h3 id="결합도와-응집도의-충돌"><a href="#결합도와-응집도의-충돌" class="headerlink" title="결합도와 응집도의 충돌"></a>결합도와 응집도의 충돌</h3><p>묻지 말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로만 나타나지 안흔ㄴ다. </p><p>모든 상황에서 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존하게 된다. </p><p><strong>클래스는 하나의 변경 원인만을 가져야한다.</strong> 서로 상관 없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 낮은 변경으로도 쉽게 무너질수 있다. </p><hr><p>디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다고 설명한다. 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다. </p><p>원칙을 맹신하지 마라. 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라. </p><p>설계는 트레이드오프의 산물이다. 소프트웨어 설계에 존재하는 몇 안되는 법칙중 하나는<code>&quot;경우에 따라 다르다&quot;</code> 라는 사실을 명심하라</p><h2 id="04-명령-쿼리-분리-원칙"><a href="#04-명령-쿼리-분리-원칙" class="headerlink" title="04. 명령-쿼리 분리 원칙"></a>04. 명령-쿼리 분리 원칙</h2><p><strong>루틴(routine)</strong></p><p>어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈</p><ul><li>프로시저 : 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.</li><li>함수 : 값을 반환할 수 있지만 부수효과를 발생시킬수 없다.</li></ul><p><strong>명령(command) 와 쿼리(query)</strong></p><ul><li>객체의 인터페이스 측면에서 프로시저와 함수를 부루는 또다른 이름</li><li>명령 : 객체의 상태를 수정하는 오퍼레이션</li><li>쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션</li></ul><p><strong>명령-쿼리 분리 원칙</strong></p><ul><li>오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리여야 한다.</li><li>어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.</li></ul><p><strong>명령과 쿼리를 분리하기 위한 규칙</strong></p><blockquote><ul><li><p>객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.</p></li><li><p>객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.</p></li></ul></blockquote><p><strong>명령-쿼리 인터페이스(Command-Query Interface) - 마틴 파울러</strong></p><ul><li>명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스</li></ul><hr><h3 id="반복-일정의-명령과-쿼리-분리하기"><a href="#반복-일정의-명령과-쿼리-분리하기" class="headerlink" title="반복 일정의 명령과 쿼리 분리하기"></a>반복 일정의 명령과 쿼리 분리하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime from;</span><br><span class="line">    <span class="keyword">private</span> Duration duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(String subject, LocalDateTime from, Duration duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfied</span><span class="params">(RecurringSchedule schedule)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from.getDayOfWeek() != schedule.getDayOfWeek() ||</span><br><span class="line">                !from.toLocalTime().equals(schedule.getFrom()) ||</span><br><span class="line">                !duration.equals(schedule.getDuration())</span><br><span class="line">        ) &#123;</span><br><span class="line">            reschedule(schedule);</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">(RecurringSchedule schedule)</span> </span>&#123;</span><br><span class="line">        from = LocalDateTime.of</span><br><span class="line">                (from.toLocalDate().plusDays(daysDistance(schedule)), schedule.getFrom());</span><br><span class="line">        duration = schedule.getDuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">daysDistance</span><span class="params">(RecurringSchedule schedule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> schedule.getDayOfWeek().getValue() - from.getDayOfWeek().getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfied</span><span class="params">(RecurringSchedule schedule)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">(RecurringSchedule schedule)</span> </span>&#123;  ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">..... </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** client 호출 **/</span></span><br><span class="line">  <span class="keyword">if</span>(!event.isSatisfied(schedule))&#123;</span><br><span class="line">    event.reschedule(schedule);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>명령과 쿼리를 분리함으로써 예측가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해졌다.</li></ul><h3 id="명령-쿼리-분리와-참조-투명성"><a href="#명령-쿼리-분리와-참조-투명성" class="headerlink" title="명령-쿼리 분리와 참조 투명성"></a>명령-쿼리 분리와 참조 투명성</h3><h3 id="책임에-초점을-맞춰라"><a href="#책임에-초점을-맞춰라" class="headerlink" title="책임에 초점을 맞춰라"></a>책임에 초점을 맞춰라</h3><ul><li>디미터 법칙<ul><li>협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 나줄 수 있다.</li></ul></li><li>묻지 말고시켜라<ul><li>메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. 클라이언트 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.</li></ul></li><li>의도를 드러내는 인터페이스<ul><li>메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것. </li></ul></li><li>명령-쿼리 분리 원칙<ul><li>예측가능한 협력을 만들기 위해 명령과 쿼리를 분리</li></ul></li></ul><p><strong>훌륭한 메시지를 얻기 위한 출발점</strong>은 책임 주도  설계 원칙을 따르는 것. </p><p>책임 주도 설계에서는 객체가 메시지를 선택하는 것이 아닌 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다. </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-06-메시지와-인터페이스&quot;&gt;&lt;a href=&quot;#chapter-06-메시지와-인터페이스&quot; class=&quot;headerlink&quot; title=&quot;chapter 06. 메시지와 인터페이스&quot;&gt;&lt;/a&gt;chapter 06. 메시지와 인터페이스&lt;/h1&gt;&lt;p&gt;객체지향 프로그래밍에 대한 가장 흔한 오해 &lt;/p&gt;&lt;ul&gt;
&lt;li&gt;애플리케이션은 클래스의 집합으로 구성된다. &lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;애플리케이션&lt;/code&gt;은 클래스로 구성되지만&lt;code&gt;메시지를 통해 정의&lt;/code&gt;된다.&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;01-협력과-메시지&quot;&gt;&lt;a href=&quot;#01-협력과-메시지&quot; class=&quot;headerlink&quot; title=&quot;01. 협력과 메시지&quot;&gt;&lt;/a&gt;01. 협력과 메시지&lt;/h2&gt;&lt;h3 id=&quot;클라이언트-서버-모델&quot;&gt;&lt;a href=&quot;#클라이언트-서버-모델&quot; class=&quot;headerlink&quot; title=&quot;클라이언트-서버 모델&quot;&gt;&lt;/a&gt;클라이언트-서버 모델&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;협력안에서 메시지를 전송하는 객체를 &lt;strong&gt;클라이언트&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메세지를 수신하는 객체를 &lt;strong&gt;서버&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 05. 책임 할당하기.</title>
    <link href="https://dschoi.github.io/2020/02/11/objects-05/"/>
    <id>https://dschoi.github.io/2020/02/11/objects-05/</id>
    <published>2020-02-11T13:58:34.000Z</published>
    <updated>2020-04-28T12:47:22.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-05-책임-할당하기"><a href="#chapter-05-책임-할당하기" class="headerlink" title="chapter 05. 책임 할당하기."></a>chapter 05. 책임 할당하기.</h1><h2 id="01-책임-주도-설계를-향해"><a href="#01-책임-주도-설계를-향해" class="headerlink" title="01. 책임 주도 설계를 향해"></a>01. 책임 주도 설계를 향해</h2><p>데이터 중심 설계에서 책임 중심 설계로 전환하기 위한 두가지 원칙 </p><ul><li>데이터보다 행동을 먼저 결정하라</li><li>협력이라는 문맥 안에서 책임을 결정하라</li></ul><h3 id="데이터보다-행동을-먼저-결정하라"><a href="#데이터보다-행동을-먼저-결정하라" class="headerlink" title="데이터보다 행동을 먼저 결정하라."></a>데이터보다 행동을 먼저 결정하라.</h3><p>클라이언트 관점에서 객체가 수행하는 행동이란 곧 객체의 책임이다. </p><a id="more"></a><p>데이터는 객체가 책임을 수행하는데 필요한 재료일 뿐이다. </p><p>너무 이른 시기에 데이터에 초점을 맞추면 객체의 캡슐화가 약화되기 때문에 낮은 응집도와 높은 결합도를 가진 객체들로 넘쳐나게 된다.</p><p><strong>객체의 데이터에서 행동으로 무게 중심을 옮기기 위한 기법</strong></p><ul><li>객체를 설계하기 위한 질문의 순서를 바꾸기<ul><li>객체가 포함해야 하는 데이터가 무엇인가? 를 결정 후  이 데이터를 처리하는데 필요한 오퍼레이션은 무엇인가? </li><li>이 객체가 수행하는 책임은 무엇인가?  결정 후 이 책임을 수행하는데 필요한 데이터는 무엇인가? </li></ul></li></ul><h3 id="협력이라는-문맥-안에서-책임을-결정하라"><a href="#협력이라는-문맥-안에서-책임을-결정하라" class="headerlink" title="협력이라는 문맥 안에서 책임을 결정하라."></a>협력이라는 문맥 안에서 책임을 결정하라.</h3><p>객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜것이다. </p><p>객체의 책임을 어떻게 식별해야 하는가에 대한 힌트</p><ul><li>책임은 객체의 입장의 아니라 객체가 참여하는 협력에 적합해야한다. </li><li>협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아닌 전송자에 적합한 책임</li></ul><p><code>객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야한다.</code></p><blockquote><p>클래스를 결정하고 그 클래스의 책임을 찾아나서는 대신 메시지를 결정하고 이 메시지를 누구에게 전송할지 찾아보게 되었다.  </p><p>클래스 기반 설계에서 메시지 기반 설계로의 자리바꿈은 우리가 해오던 설계 활동의 전환점이다. 메시지 기반의 설계 관점은 클래스 기반의 설계관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해준다. “이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지? “ 라고 질문하지 않고 “메시지를 전송해야 하는데 누구에게 전송해야 하지?” 라고 질문하는 것. 설계의 핵심 질문을 이렇게 바꾸는 것이 메시지 기반 설계로 향하는 첫걸음이다. </p><p>객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 때문에 객체를 갖게 된 것이다. </p></blockquote><h3 id="책임-주도-설계"><a href="#책임-주도-설계" class="headerlink" title="책임 주도 설계"></a>책임 주도 설계</h3><p><strong>책임 주도 설계의 흐름</strong></p><ul><li>시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.</li><li>시스템 책임을 더 작은 책임으로 분할한다.</li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 객체 또는 역할을 찾는다.</li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ul><p><strong>책임 주도 설계의 핵심</strong></p><blockquote><p> 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것</p></blockquote><h2 id="02-책임-할당을-위한-GRASP-패턴"><a href="#02-책임-할당을-위한-GRASP-패턴" class="headerlink" title="02. 책임 할당을 위한 GRASP 패턴"></a>02. 책임 할당을 위한 GRASP 패턴</h2><p>크레이그 라만(Craig Larman) - GRASP 패턴</p><p><code>General Responsibility Assignment Software pattern (일반적인 책임 할당을 위한 소프트웨어 패턴)</code></p><h3 id="도메인-개념에서-출발하기"><a href="#도메인-개념에서-출발하기" class="headerlink" title="도메인 개념에서 출발하기"></a>도메인 개념에서 출발하기</h3><img src="/2020/02/11/objects-05/image-20200218004118152.png" alt="image-20200218004118152" style="zoom:50%;"><p><strong>올바른 도메인 모델이란 존재 하지 않는다.</strong></p><h3 id="정보-전문가에게-책임을-할당하라"><a href="#정보-전문가에게-책임을-할당하라" class="headerlink" title="정보 전문가에게 책임을 할당하라"></a>정보 전문가에게 책임을 할당하라</h3><p><strong>첫번째 질문 ?</strong></p><p><code>메시지를 전송할 객체는 무엇을 원하는가?</code></p><img src="/Users/setin82/git/dsChoi/source/_posts/objects-05/image-20200218004400922.png" alt="image-20200218004400922" style="zoom:50%; float:left;"><p><strong>두번째 질문?</strong></p><p><code>메시지를 수신할 적합한 객체는 누구인가?</code></p><p><strong>객체에게 책임을 할당하는 첫번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것</strong></p><p><strong>Information Expert 패턴</strong></p><blockquote><p>책임을 객체에 할당하는 일반적인 원리는? 책임을 정보 전문가, 즉 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라.</p></blockquote><img src="/2020/02/11/objects-05/image-20200218005130994.png" alt="image-20200218005130994" style="zoom:50%;"><h3 id="높은-응집도와-낮은-결합도"><a href="#높은-응집도와-낮은-결합도" class="headerlink" title="높은 응집도와 낮은 결합도"></a>높은 응집도와 낮은 결합도</h3><p><strong>응집도와 결합도</strong></p><p>높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리.</p><ul><li>책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.</li></ul><p>*<em>Low Coupling(낮은 결합도) 패턴 *</em></p><blockquote><p>어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을가? 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.</p></blockquote><p><strong>High Cohesion(높은 응집도) 패턴</strong></p><blockquote><p>어떻게 복잡성을 관리할 수 있는 수준으로 유지할것인가? 높은 응집도를 유지할 수 있게 책임을 할당하라.</p><p>낮은 결합도 처럼 높은 응집도 역시 모든 설계 결정에서 염두에 두어야 할 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 잇는 평가 원리다. </p></blockquote><h3 id="창조자에게-객체-생성-책임을-할당하라"><a href="#창조자에게-객체-생성-책임을-할당하라" class="headerlink" title="창조자에게 객체 생성 책임을 할당하라."></a>창조자에게 객체 생성 책임을 할당하라.</h3><p><strong>Creator(창조자) 패턴</strong></p><blockquote><p>객체 A 를 생성해야 할때 어떤 객체에게  생성 책임을 할당해야 하나? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.</p><ul><li>B가 A 객체를 포함하거나 참조한다.</li><li>B가 A 객체를 기록한다.</li><li>B가 A 객체를 긴밀하게 사용한다.</li><li>B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. ( 이 경우는 B는 A에 대한 정보전분가다.)</li></ul></blockquote><h2 id="03-구현을-통한-검증"><a href="#03-구현을-통한-검증" class="headerlink" title="03. 구현을 통한 검증"></a>03. 구현을 통한 검증</h2><p>…</p><h3 id="DiscountCondition-개선하기"><a href="#DiscountCondition-개선하기" class="headerlink" title="DiscountCondition 개선하기"></a>DiscountCondition 개선하기</h3><p>변경의 이유</p><ul><li>새로운 할인 조건 추가</li><li>순번 조건을 판단하는 로직 변경</li><li>기간 조건을 판단하는 로직 변경</li></ul><p>*<em>변경의 이유에 따라 클래스를 분리해야 한다. *</em></p><p><strong>클래스 응집도 판단하기</strong></p><blockquote><ul><li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.</li><li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은것이다. 초기화 되는 속성의 그룹을 기준으로 클래스를 분리하라.</li><li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라.</li></ul></blockquote><h3 id="타입-분리하기"><a href="#타입-분리하기" class="headerlink" title="타입 분리하기"></a>타입 분리하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;PeriodCondition&gt; periodConditions;</span><br><span class="line">  <span class="keyword">private</span> List&lt;SequenceCondition&gt; sequenceConditions;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>문제점</strong></p><ol><li>Movie 클래스가 PeriodCondition , SequenceCondition과 결합된다.</li><li>새로운 할인 조건을 추가하기가 더 어려워졌다. </li></ol><h3 id="다형성을-통해-분리하기"><a href="#다형성을-통해-분리하기" class="headerlink" title="다형성을 통해 분리하기"></a>다형성을 통해 분리하기</h3><img src="/2020/02/11/objects-05/image-20200218010942793.png" alt="image-20200218010942793" style="zoom:50%;float:left"><p><strong>Polymorphism 패턴</strong></p><blockquote><p>객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 할까? 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.</p><p>조건에 따른 변화는 프로그램의 기본 논리다. 프로그램을 if -else 또는 swith-case 등의 조건 논리를 사용하면 새로운 변화가 생길 경우 조건 논리를 수정해야 한다. </p><p>Polymorphism 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고한다. 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.</p></blockquote><h3 id="변경으로부터-보호하기"><a href="#변경으로부터-보호하기" class="headerlink" title="변경으로부터 보호하기"></a>변경으로부터 보호하기</h3><p>변경을 캡슐화 하고 책임을 할당하는 것</p><p><strong>Protected Variations (변경 보호) 패턴</strong></p><blockquote><p>객체, 서브시스템, 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까? 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라. </p><p>Protected Variations 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것. “설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해라” 라는 객체지향의 오랜 격언은 변경보호 패턴의 본질을 설명해준다. <strong>우리가 캡슐화해야 하는 것은 변경이다.</strong>  변경이 될 가능성이 높은가? 그러면 캡슐화하라.</p></blockquote><h3 id="Movie-클래스-개선하기"><a href="#Movie-클래스-개선하기" class="headerlink" title="Movie  클래스 개선하기"></a>Movie  클래스 개선하기</h3><h3 id="변경과-유연성"><a href="#변경과-유연성" class="headerlink" title="변경과 유연성"></a>변경과 유연성</h3><h2 id="04-책임-주도-설계의-대안"><a href="#04-책임-주도-설계의-대안" class="headerlink" title="04. 책임 주도 설계의 대안"></a>04. 책임 주도 설계의 대안</h2><p><strong>리팩토링</strong></p><blockquote><p>이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것</p></blockquote><h3 id="메서드-응집도"><a href="#메서드-응집도" class="headerlink" title="메서드 응집도"></a>메서드 응집도</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.setin.study.objects.chapter04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">        Movie movie = screening.getMovie();</span><br><span class="line">        <span class="keyword">boolean</span> discountable = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (DiscountCondition condition : movie.getDiscountConditions()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.getType() == DiscountConditionType.PERIOD) &#123;</span><br><span class="line">                discountable = screening.getWhenScreened()</span><br><span class="line">                  .getDayOfWeek().equals(condition.getDayOfWeek())</span><br><span class="line">                        &amp;&amp; condition.getStartTime()</span><br><span class="line">                  .compareTo(screening.getWhenScreened()</span><br><span class="line">                             .toLocalTime()) &lt;= <span class="number">0</span></span><br><span class="line">                        &amp;&amp; condition.getEndTime()</span><br><span class="line">                  .compareTo(screening.getWhenScreened()</span><br><span class="line">                             .toLocalTime()) &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                discountable = condition.getSequence() == screening.getSequence();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Money fee;</span><br><span class="line">        <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">            Money discountAmount = Money.ZERO;</span><br><span class="line">            <span class="keyword">switch</span> (movie.getMovieType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                    discountAmount = movie.getDiscountAmount();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                    discountAmount = movie.getFee().times(movie.getDiscountPercent());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> NONE_DISCOUNT:</span><br><span class="line">                    discountAmount = Money.ZERO;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fee = movie.getFee();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reservation(customer, screening, fee, audienceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>긴 메서드는 다양한 측면에서 코드 유지 보수에 부정적인 영향을 미친다. </p><p><strong>몬스터 메소드 - 마이클 페더스(Michael Feathers)</strong></p><ul><li>어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는데 너무 많은 시간이 걸린다.</li><li>하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.</li><li>메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.</li><li>로직의 일부만 재사용하는 것이 불가능하다.</li><li>코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 중복을 초래하기 쉽다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> discountable = checkDiscountable(screening);</span><br><span class="line">       Money fee = calculate(screening, discountable, audienceCount);</span><br><span class="line">       <span class="keyword">return</span> createReservation(screening, customer, audienceCount, fee);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="객체를-자율적으로-만들자"><a href="#객체를-자율적으로-만들자" class="headerlink" title="객체를 자율적으로 만들자"></a>객체를 자율적으로 만들자</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(DiscountCondition condition, Screening screening)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(condition.getType() == DiscountConditionType.PERIOD)&#123;</span><br><span class="line">            <span class="keyword">return</span>  isSatisfiedByPeriod(condition, screening);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSatisfiedBySequence(condition, screening);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBySequence</span><span class="params">(DiscountCondition condition, Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition.getSequence() == screening.getSequence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedByPeriod</span><span class="params">(DiscountCondition condition, Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &amp;&amp;</span><br><span class="line">                condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) &gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DiscountConditionType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line">    <span class="keyword">private</span> DayOfWeek dayOfWeek;</span><br><span class="line">    <span class="keyword">private</span> LocalTime startTime;</span><br><span class="line">    <span class="keyword">private</span> LocalTime endTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == DiscountConditionType.PERIOD) &#123;</span><br><span class="line">            <span class="keyword">return</span> isSatisfiedByPeriod(screening);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSatisfiedBySequence(screening);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sequence == screening.getSequence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedByPeriod</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screening.getWhenScreened().getDayOfWeek().equals(dayOfWeek) &amp;&amp;</span><br><span class="line">                startTime.compareTo(screening.getWhenScreened().toLocalTime()) &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                endTime.compareTo(screening.getWhenScreened().toLocalTime()) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>discountCondition 내부에서만 인자에 접근가능하고 완벽한 캡슐화를 이룰수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkDiscountable</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> screening.getMovie().getDiscountConditions().stream()</span><br><span class="line">      .anyMatch(condition -&gt; condition.isDiscountable(screening));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동.</p></li><li><p>메서드를 다른 클래스로 이동시킬 때는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적</p></li><li><p>데이터를 사용하는 메서드를 데이터를 가진 클래스로 이동시키고 나면 캡슐화와 높은 응집도, 낮은 결합도를 가지는 설계를 가지게 된다.</p></li></ul><p><strong>책임 주도 설계방법에 익숙하지 않다면?</strong></p><p>데이터 중심으로 구현한 후 이를 래팩토링하더라도 유사한 결과를 얻을수 있다.  캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용하기 위해 노력한다면 책임 주도 설계 방법을 단계적으로 따르지 않더라도 유연하고 깔끔한 코드를 얻을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-05-책임-할당하기&quot;&gt;&lt;a href=&quot;#chapter-05-책임-할당하기&quot; class=&quot;headerlink&quot; title=&quot;chapter 05. 책임 할당하기.&quot;&gt;&lt;/a&gt;chapter 05. 책임 할당하기.&lt;/h1&gt;&lt;h2 id=&quot;01-책임-주도-설계를-향해&quot;&gt;&lt;a href=&quot;#01-책임-주도-설계를-향해&quot; class=&quot;headerlink&quot; title=&quot;01. 책임 주도 설계를 향해&quot;&gt;&lt;/a&gt;01. 책임 주도 설계를 향해&lt;/h2&gt;&lt;p&gt;데이터 중심 설계에서 책임 중심 설계로 전환하기 위한 두가지 원칙 &lt;/p&gt;&lt;ul&gt;
&lt;li&gt;데이터보다 행동을 먼저 결정하라&lt;/li&gt;
&lt;li&gt;협력이라는 문맥 안에서 책임을 결정하라&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;데이터보다-행동을-먼저-결정하라&quot;&gt;&lt;a href=&quot;#데이터보다-행동을-먼저-결정하라&quot; class=&quot;headerlink&quot; title=&quot;데이터보다 행동을 먼저 결정하라.&quot;&gt;&lt;/a&gt;데이터보다 행동을 먼저 결정하라.&lt;/h3&gt;&lt;p&gt;클라이언트 관점에서 객체가 수행하는 행동이란 곧 객체의 책임이다. &lt;/p&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 04. 설계 품질과 트레이드오프</title>
    <link href="https://dschoi.github.io/2020/02/10/object-04/"/>
    <id>https://dschoi.github.io/2020/02/10/object-04/</id>
    <published>2020-02-09T16:05:07.000Z</published>
    <updated>2020-04-28T12:47:05.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-04-설계-품질과-트레이드오프"><a href="#chapter-04-설계-품질과-트레이드오프" class="headerlink" title="chapter 04. 설계 품질과 트레이드오프"></a>chapter 04. 설계 품질과 트레이드오프</h1><blockquote><p>객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.</p></blockquote><ol><li>객체지향 설계의 핵심은 책임</li><li>책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연계되어있다. </li></ol><a id="more"></a><h2 id="01-데이터-중심의-영화-예매-시스템"><a href="#01-데이터-중심의-영화-예매-시스템" class="headerlink" title="01 . 데이터 중심의 영화 예매 시스템"></a>01 . 데이터 중심의 영화 예매 시스템</h2><p><strong>객체지향 설계의 시스템을 객체로 분할하는 두가지 방법</strong></p><ol><li>상태를 분할의 중심축으로 </li><li>책임을 분할의 중심축으로</li></ol><p><code>상태</code> =<code>데이터</code></p><h3 id="데이터를-준비하자"><a href="#데이터를-준비하자" class="headerlink" title="데이터를 준비하자"></a>데이터를 준비하자</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Duration runningTime;</span><br><span class="line">    <span class="keyword">private</span> Money fee;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieType movieType;</span><br><span class="line">    <span class="keyword">private</span> Money discountAmount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> discountPercent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MovieType &#123;</span><br><span class="line">    AMOUNT_DISCOUNT, <span class="comment">//금액 할인 정책</span></span><br><span class="line">    PERCENT_DISCOUNT, <span class="comment">//비율 할인 정책</span></span><br><span class="line">    NONE_DISCOUNT <span class="comment">// 미적용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체지향의 가장 중요한 원칙인 캡슐화를 위해 Movie 클래스에  <strong>접근자(accessor)</strong>와 <strong>수정자(mutator)</strong>를 추가. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> title;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.title = title;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Duration <span class="title">getRunningTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> runningTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunningTime</span><span class="params">(Duration runningTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.runningTime = runningTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Money <span class="title">getFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fee;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>소스코드는 아래 링크에 추가해놓았으니 확인 바랍니다.</p><p><a href="https://github.com/dsChoi/study/tree/master/src/main/java/com/setin/study/objects/chapter04" target="_blank" rel="noopener">https://github.com/dsChoi/study/tree/master/src/main/java/com/setin/study/objects/chapter04</a></p><p><strong>영화 예매 시스템 구현을 위한 데이터 클래스</strong></p><img src="/2020/02/10/object-04/image-20200211220131058.png" alt="image-20200211220131058" style="zoom:50%;"><h3 id="영화를-예매하자"><a href="#영화를-예매하자" class="headerlink" title="영화를 예매하자"></a>영화를 예매하자</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">        Movie movie = screening.getMovie();</span><br><span class="line">        <span class="keyword">boolean</span> discountable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DiscountCondition condition : movie.getDiscountConditions()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.getType() == DiscountConditionType.PERIOD) &#123;</span><br><span class="line">                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek())</span><br><span class="line">                        &amp;&amp; condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) &lt;= <span class="number">0</span></span><br><span class="line">                        &amp;&amp; condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                discountable = condition.getSequence() == screening.getSequence();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Money fee;</span><br><span class="line">        <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">            Money discountAmount = Money.ZERO;</span><br><span class="line">            <span class="keyword">switch</span> (movie.getMovieType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                    discountAmount = movie.getDiscountAmount();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                    discountAmount = movie.getFee().times(movie.getDiscountPercent());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> NONE_DISCOUNT:</span><br><span class="line">                    discountAmount = Money.ZERO;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fee = movie.getFee();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reservation(customer, screening, fee, audienceCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-설계-트레이드오프"><a href="#02-설계-트레이드오프" class="headerlink" title="02. 설계 트레이드오프"></a>02. 설계 트레이드오프</h2><h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><ul><li>외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화 하는 추상화의 한 종류</li><li>객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는 것</li></ul><blockquote><p>복잡성을 다루기 위한 가장 효과적인 도구는 추상화다. 다양한 추상화 유형을 사용할 수 있지만 객체지향 프로그래밍에서 복잡성을 취급하는 주요한 추상화 방법은 캡슐화다. 그러나 객체지향 언어를 사용한다해서 잘 캡슐화 된다는 보장은 없다.<br>객체지향 프로그래밍을 통해 전반적으로 얻을 수 있는 장점은 오직 설계 과정 동안 캡슐화를 목표로 인식할때만 달성될 수 있다.</p></blockquote><h3 id="응집도와-결합도"><a href="#응집도와-결합도" class="headerlink" title="응집도와 결합도"></a>응집도와 결합도</h3><p><strong>응집도</strong></p><p>모듈에 포함된 내부 요소들이 연관되어 있는 정도</p><p><strong>결합도</strong></p><p>의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도</p><p>높은 응집도와 낮은 결합도를 가진 설계를 추구해야하는 이유는  그것이 <strong>설계를 변경하기 쉽게 만들기 때문.</strong></p><p>응집도가 높은 설계에서는 하나의 요구사항을 변경하기 위해 하나의 모듈만 수정하면된다.</p><p>응집도가 낮은 설계에서는 하나의 요구사항을 변경하기 위해 여러 모듈을 동시에 수정해야한다.</p><img src="/2020/02/10/object-04/image-20200211221736869.png" alt="image-20200211221736869" style="zoom:50%;"><p>결합도는 <strong>한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도</strong> </p><img src="/2020/02/10/object-04/image-20200211222351496.png" alt="image-20200211222351496" style="zoom:50%;"><h2 id="03-데이터-중심의-영화-예매-시스템의-문제점"><a href="#03-데이터-중심의-영화-예매-시스템의-문제점" class="headerlink" title="03. 데이터 중심의 영화 예매 시스템의 문제점"></a>03. 데이터 중심의 영화 예매 시스템의 문제점</h2><p>데이터 중심의 설계가 가진 대표적인 문제점</p><ul><li>캡슐화 위반</li><li>높은 결합도</li><li>낮은 응집도</li></ul><h3 id="캡슐화-위반"><a href="#캡슐화-위반" class="headerlink" title="캡슐화 위반"></a>캡슐화 위반</h3><p>앨런 홀럽 : 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라 부른다. </p><p>get, set 메소드로 인해 movie 가 Money타입을 가지는 fee라는 인스턴스 변수가 존재하는 것을 인터페이스에서 노출.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Money fee;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Money <span class="title">getFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFee</span><span class="params">(Money fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fee = fee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="높은-결합도"><a href="#높은-결합도" class="headerlink" title="높은 결합도"></a>높은 결합도</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Money fee;</span><br><span class="line">        <span class="keyword">if</span> (discountable) &#123;</span><br><span class="line">        ...</span><br><span class="line">            fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fee = movie.getFee();</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>너무 많은 대상에 의존하기에 변경에 취약한 ReservationAgency</strong></p><img src="/2020/02/10/object-04/image-20200211223139559.png" alt="image-20200211223139559" style="zoom:50%;"><h3 id="낮은-응집도"><a href="#낮은-응집도" class="headerlink" title="낮은 응집도"></a>낮은 응집도</h3><p>ReservationAgency 에  다음과 같은 수정사항이 발생할 경우 코드를 수정해야할 것</p><ul><li>할인 정책이 추가될 경우</li><li>할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우</li><li>할인 조건이 추가되는 경우</li><li>할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우</li><li>예매 요금을 계산하는 방법이 변경될 경우</li></ul><p><strong>낮은 응집도는 두가지 측면에서 설계에 문제를 일으킨다.</strong></p><ul><li>변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐 놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받는다.</li><li>하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 다른 모듈에 위치해야 할 책임의 일부가 엉뚱한 곳에 위치하기 때문이다. </li></ul><p><strong>단일 책임 원칙(Single Responsibility Principle, SRP)</strong></p><blockquote><p>로버트 마틴 , 클래스는 단 한가지의 변경 이유만 가져야 한다는 것이다. </p></blockquote><h2 id="04-자율적인-객체를-향해"><a href="#04-자율적인-객체를-향해" class="headerlink" title="04. 자율적인 객체를 향해"></a>04. 자율적인 객체를 향해</h2><h3 id="캡슐화를-지켜라"><a href="#캡슐화를-지켜라" class="headerlink" title="캡슐화를 지켜라"></a>캡슐화를 지켜라</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">any</span><span class="params">(Rectangle rectangle, <span class="keyword">int</span> muliple)</span></span>&#123;</span><br><span class="line">    rectangle.setRight(rectangle.getRight() * multiple);</span><br><span class="line">    rectangle.setBottom(rectangle.getBottom() * multiple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlarge</span><span class="params">(<span class="keyword">int</span> multiple)</span></span>&#123;</span><br><span class="line">    right *= muliple;</span><br><span class="line">    bottom *= multiple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="스스로-자신의-데이터를-책임지는-객체"><a href="#스스로-자신의-데이터를-책임지는-객체" class="headerlink" title="스스로 자신의 데이터를 책임지는 객체"></a>스스로 자신의 데이터를 책임지는 객체</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DiscountConditionType type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line">    <span class="keyword">private</span> DayOfWeek dayOfWeek;</span><br><span class="line">    <span class="keyword">private</span> LocalTime startTime;</span><br><span class="line">    <span class="keyword">private</span> LocalTime endTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(DayOfWeek dayOfWeek, LocalTime time )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type != DiscountConditionType.PERIOD)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dayOfWeek.equals(dayOfWeek) &amp;&amp;</span><br><span class="line">                <span class="keyword">this</span>.startTime.compareTo(time) &lt;=<span class="number">0</span> &amp;&amp;</span><br><span class="line">                <span class="keyword">this</span>.endTime.compareTo(time) &gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(<span class="keyword">int</span> sequence)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type != DiscountConditionType.SEQUENCE)&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sequence == sequence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateAmountDiscountedFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (movieType != MovieType.AMOUNT_DISCOUNT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(discountAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculatePercentDiscountedFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (movieType != MovieType.PERCENT_DISCOUNT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(fee.times(discountPercent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateNoneDiscountedFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (movieType != MovieType.NONE_DISCOUNT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fee;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(LocalDateTime whenScreend, <span class="keyword">int</span> sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DiscountCondition condition : discountConditions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.getType() == DiscountConditionType.PERIOD) &#123;</span><br><span class="line">                <span class="keyword">return</span> condition.isDiscountable(whenScreend.getDayOfWeek(), whenScreend.toLocalTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> condition.isDiscountable(sequence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationAgency</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reservation <span class="title">reserve</span><span class="params">(Screening screening, Customer customer, <span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">        Money fee = screening.calculateFee(audienceCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reservation(customer, screening, fee, audienceCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 결합도 측면에서 이전보다 개선된 설계**</p><img src="/2020/02/10/object-04/image-20200211224204466.png" alt="image-20200211224204466" style="zoom:50%;"><h2 id="05-하지만-여전히-부족하다"><a href="#05-하지만-여전히-부족하다" class="headerlink" title="05. 하지만 여전히 부족하다"></a>05. 하지만 여전히 부족하다</h2><h3 id="캡슐화-위반-1"><a href="#캡슐화-위반-1" class="headerlink" title="캡슐화 위반"></a>캡슐화 위반</h3><p>Movie 는 아래 세개 메서드를 통해 할인 정책에는 금액, 비율, 미적용 정책이 세가지 존재한다는 것을 노출한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateAmountDiscountedFee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculatePercentDiscountedFee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateNoneDiscountedFee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>캡슐화의 진정한 의미</strong></p><blockquote><p>캡슐화가 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를  잘 보여준다. 사실 캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미. 내부 속성을 외부로부터 감추는 것은 ‘데이터 캡슐화’ 라는 캡슐화의 한 종류일 뿐. </p><p>캡슐화는 변하는 것 어떤 것이든 감추는 것이다. 그것이 무엇이든 구현과 관련된 것이라면.. </p></blockquote><h3 id="높은-결합도-1"><a href="#높은-결합도-1" class="headerlink" title="높은 결합도"></a>높은 결합도</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDiscountable</span><span class="params">(LocalDateTime whenScreend, <span class="keyword">int</span> sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DiscountCondition condition : discountConditions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.getType() == DiscountConditionType.PERIOD) &#123;</span><br><span class="line">                <span class="keyword">return</span> condition.isDiscountable(whenScreend.getDayOfWeek(), whenScreend.toLocalTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> condition.isDiscountable(sequence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>DiscountCondition의 기간 할인 조건의 명칭이 PERIOD에서 다른 값을 변경되면 Movie를 수정해야한다.</p></li><li><p>DiscountCondition의 종류가 추가되거나 삭제되면 if-else 구문을 수정해야한다.</p></li><li><p>DiscountCondition의 만족여부를 판단하는데 필요한 정보가 변경되면 Movie의 <code>isDiscountable</code> 메서드로 전달되는 파라미터를 변겨앻야한다. </p></li></ul><h3 id="낮은-응집도-1"><a href="#낮은-응집도-1" class="headerlink" title="낮은 응집도"></a>낮은 응집도</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screening</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Money <span class="title">calculateFee</span><span class="params">(<span class="keyword">int</span> audienceCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (movie.getMovieType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AMOUNT_DISCOUNT:</span><br><span class="line">                <span class="keyword">if</span> (movie.isDiscountable(whenScreened, sequence)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> movie.calculateAmountDiscountedFee().times(audienceCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PERCENT_DISCOUNT:</span><br><span class="line">                <span class="keyword">if</span> (movie.isDiscountable(whenScreened, sequence)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> movie.calculatePercentDiscountedFee().times(audienceCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> NONE_DISCOUNT:</span><br><span class="line">                <span class="keyword">return</span> movie.calculateNoneDiscountedFee().times(audienceCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> movie.calculateNoneDiscountedFee().times(audienceCount);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>할인 조건을 변경하려면 DiscountCondition, Movie, Screening을 함께 수정해야한다. </p><h2 id="06-데이터-중심-설계의-문제점"><a href="#06-데이터-중심-설계의-문제점" class="headerlink" title="06. 데이터 중심 설계의 문제점"></a>06. 데이터 중심 설계의 문제점</h2><p>데이터 중심의 설계가 변경에 취약한 이유</p><ol><li>데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 한다.</li><li>데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. </li></ol><h3 id="데이터-중심-설계는-객체의-행동보다는-상태에-초점을-맞춘다"><a href="#데이터-중심-설계는-객체의-행동보다는-상태에-초점을-맞춘다" class="headerlink" title="데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다."></a>데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.</h3><p>*<em>데이터는 구현의 일부라는 사실을 명심하라. *</em></p><ul><li>데이터 중심설계에서 객체는 단순 데이터의 집합체일 뿐이다. </li></ul><p>너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다. 객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경에 취약한 코드를 낳게 된다. </p><h3 id="데이터-중심-설계는-객체를-고립시킨-채-오퍼레이션을-정의하도록-만든다"><a href="#데이터-중심-설계는-객체를-고립시킨-채-오퍼레이션을-정의하도록-만든다" class="headerlink" title="데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다."></a>데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.</h3><p>객체지향 설계의 무게 중심은 내부 객체가 아닌 외부에 맞춰져 있어야한다.  중요한 점은 객체가 다른 객체와 협력하는 방법이다. </p><p>데이터 중심 설계의 초점은 객체의 내부가 아닌 내부에 있다. 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.</p><p>객체의 인터페이스에 구현이 노출돼 있었기 때문에 협력이 구현 세부사항에 종속돼 있고 그에 따라 객체의 내부 구현이 변경될때 협력하는 객체 모두가 영향을 받을수 밖에 없었던 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-04-설계-품질과-트레이드오프&quot;&gt;&lt;a href=&quot;#chapter-04-설계-품질과-트레이드오프&quot; class=&quot;headerlink&quot; title=&quot;chapter 04. 설계 품질과 트레이드오프&quot;&gt;&lt;/a&gt;chapter 04. 설계 품질과 트레이드오프&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.&lt;/p&gt;
&lt;/blockquote&gt;&lt;ol&gt;
&lt;li&gt;객체지향 설계의 핵심은 책임&lt;/li&gt;
&lt;li&gt;책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연계되어있다. &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 03. 역할, 책임, 협력</title>
    <link href="https://dschoi.github.io/2020/01/28/objects-03/"/>
    <id>https://dschoi.github.io/2020/01/28/objects-03/</id>
    <published>2020-01-28T14:09:06.000Z</published>
    <updated>2020-04-28T12:47:19.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-03-역할-책임-협력"><a href="#Chapter-03-역할-책임-협력" class="headerlink" title="Chapter 03. 역할, 책임, 협력"></a>Chapter 03. 역할, 책임, 협력</h1><p><strong>객체지향 패러다임의 핵심</strong></p><ul><li>역할(role)</li><li>책임(responsibility)</li><li>협력(collaboration)</li></ul><p><strong>객체지향의 본질</strong></p><blockquote><p>협력하는 객체들의 공동체를 창조하는 것</p></blockquote><p><strong>객체지향 설계의 핵심</strong></p><blockquote><p>협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 나타난다.</p></blockquote><a id="more"></a><h2 id="01-협력"><a href="#01-협력" class="headerlink" title="01. 협력"></a>01. 협력</h2><h3 id="영화-예매-시스템-돌아보기"><a href="#영화-예매-시스템-돌아보기" class="headerlink" title="영화 예매 시스템 돌아보기"></a>영화 예매 시스템 돌아보기</h3><p><strong>책임</strong></p><p>객체가 협력에 참여하기 위해 수행하는 로직</p><p><strong>역할</strong></p><p>객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 일</p><p><strong>협력</strong></p><p>객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용</p><h3 id="협력"><a href="#협력" class="headerlink" title="협력"></a>협력</h3><blockquote><p>협력이란? </p><p>어떤 객체가 다른 객체에게 무엇인가를 요청하는 것.</p><p>객체사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.</p></blockquote><p><strong>메세지 전송</strong></p><p>객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단.</p><p>객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기에 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.</p><p><strong>메서드</strong></p><p>메세지를 수신한 객체는 <code>메서드</code> 를 실행해 요청에 응답한다.</p><ul><li>외부의 객체는 메시지만 전송할 뿐 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 결정</li></ul><img src="/2020/01/28/objects-03/image-20200204221108113.png" alt="image-20200204221108113" style="zoom:50%;"><p><strong>자율적인 객체</strong></p><p>자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체.</p><p><strong>캡슐화</strong></p><p>객체를 자율적으로 만드는 가장 기본적인 방법</p><blockquote><p>자율 적인 객체는 자신에게 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다. 메시지를 수신한 객체 역시 메시지를 처리하던 중 직접처리 할수 없는 경우 다른 객체에 도움을 요청한다. 이처럼 객체들 사이의 협력을 구성하는 요청과 응답의 흐름을 통해 애플리케이션의 기능이 구현된다.</p></blockquote><h3 id="협력이-설계를-위한-문맥을-결정한다"><a href="#협력이-설계를-위한-문맥을-결정한다" class="headerlink" title="협력이 설계를 위한 문맥을 결정한다."></a>협력이 설계를 위한 문맥을 결정한다.</h3><p><strong>객체지향</strong></p><blockquote><p> 객체를 중심에 놓는 프로그래밍 패러다임</p></blockquote><ul><li>애플리케이션에서 객체가 필요하다면 그 이유는 단 하나여야한다. 그 객체가 어떤 협력에 참여하고 있기 때문이다. 그 객체가 협력에 참여할수 있는 이유는 협력에 필요한 <code>적절한 행동</code> 을 보유하고 있기 때문이다.</li></ul><p><strong>협력</strong></p><p>객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공</p><ul><li>객체의 행동을 결정하는 것 : 협력</li><li>객체의 상태를 결정하는 것: 행동</li><li>객체가 행동하는 데 필요한 정보 : 상태</li><li>협력 안에서 객체가 처리할 메시지 : 행동</li></ul><blockquote><p>객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. </p><p>따라서. 협력은 객체를 설계하는 데 필요한 일종의 문맥(Context)를 제공한다.</p></blockquote><h2 id="02-책임"><a href="#02-책임" class="headerlink" title="02. 책임"></a>02. 책임</h2><h3 id="책임이란-무엇인가"><a href="#책임이란-무엇인가" class="headerlink" title="책임이란 무엇인가?"></a>책임이란 무엇인가?</h3><h4 id="하는-것"><a href="#하는-것" class="headerlink" title="하는 것"></a>하는 것</h4><ul><li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li><li>다른 객체의 행동을 시작시키는 것</li><li>다른 객체의 활동을 제어하고 조절하는 것</li></ul><h4 id="아는-것"><a href="#아는-것" class="headerlink" title="아는 것"></a>아는 것</h4><ul><li>사적인 정보에 관해 아는 것</li><li>관련된 객체에 관해 아는 것</li><li>자신이 유도하거나 계산할 수 있는 것에 대해 아는 것</li></ul><hr><p>책임과 메시지의 크기는 다르다.</p><p>책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 크다.</p><p>“객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어에 할당하는 것” - </p><p>사실상 , 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문.</p><h3 id="책임-할당"><a href="#책임-할당" class="headerlink" title="책임 할당"></a>책임 할당</h3><p><strong>책임 할당을 위한 정보 전문가(Information Expert) 패턴</strong></p><ul><li>자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것</li></ul><p>협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다. </p><hr><ol><li>Message  : 예매하라 </li><li>예매를 하기 위한 상영 시간 및 기본요금을 잘 알고 있는 전문가를 찾자 : Screening</li><li>영화 예매를 하기 위해서는 예매 가격을 계산해야한다.  Message: 가격을 계산하라 , 외부 메시지 전달.</li><li>가격을 계산하기 위한 할인 정책과 가격 정보를 가장 잘 알고 있는 정보 전문가를 찾자 : Movie</li></ol><img src="/2020/01/28/objects-03/image-20200204223255228.png" alt="image-20200204223255228" style="zoom:50%;"><hr><p>객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어 진다. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다.</p><p><strong>예외</strong> </p><p>응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 적당할 때. </p><h3 id="책임-주도-설계"><a href="#책임-주도-설계" class="headerlink" title="책임 주도 설계"></a>책임 주도 설계</h3><p>*<em>책임 주도 설계(Responsibility-Driven Design, RDD) - 워프스 브룩 *</em></p><blockquote><p>책임을 갖고 책임을 수행할 적절한 개게를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법</p></blockquote><ul><li>시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.</li><li>시스템 채깅ㅁ을 더 작은 책임으로 분할한다.</li><li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li><li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.</li><li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li></ul><p><code>유연하고 견고한 객체지향 시스템</code> 을 위해 가장 중요한 준비 재로는 책임.</p><h3 id="책임을-할당-할-때-고려해야-하는-두가지-요소"><a href="#책임을-할당-할-때-고려해야-하는-두가지-요소" class="headerlink" title="책임을 할당 할 때 고려해야 하는 두가지 요소."></a>책임을 할당 할 때 고려해야 하는 두가지 요소.</h3><h4 id="1-메시지가-객체를-결정한다"><a href="#1-메시지가-객체를-결정한다" class="headerlink" title="1. 메시지가 객체를 결정한다."></a>1. 메시지가 객체를 결정한다.</h4><p><strong>메시지가 객체를 선택해야 하는 두가지 중요한 이유</strong> </p><ol><li><p>객체가 최소한의 인터페이스를 가질수 있게 된다.</p><ul><li>필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 필요한 크기의 퍼블릭 인터페이스를 가질수 있다. </li></ul></li><li><p>객체는 충분히 추상적인 인터페이스를 가질수 있게 된다. </p><ul><li>객체의 인터페이스는 무엇을 하는지 표현해야 하지 어떻게 수행하는지를 노출해서는 안된다.</li></ul></li></ol><h4 id="2-행동이-상태를-결정한다"><a href="#2-행동이-상태를-결정한다" class="headerlink" title="2. 행동이 상태를 결정한다."></a>2. 행동이 상태를 결정한다.</h4><p>객체가 존재하는 이유는 협력에 참여하기 위해서다.</p><p><strong>객체를 객체답게 만드는 것</strong>은 객체의 상태가 아닌 <code>객체가 다른 객체에게 제공하는 행동이다.</code></p><hr><p>객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아닌 상태에 초점을 맞추는 것이다. </p><p>협력이 객체의 행동을 결정하고 행동이 상태를 결정한다. 그리고 행동이 바로 그 객체의 책임이다. </p><h2 id="03-역할"><a href="#03-역할" class="headerlink" title="03. 역할"></a>03. 역할</h2><h3 id="역할과-협력"><a href="#역할과-협력" class="headerlink" title="역할과 협력"></a>역할과 협력</h3><p><strong>역할</strong></p><p>객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합</p><h3 id="유연하고-재사용-가능한-협력"><a href="#유연하고-재사용-가능한-협력" class="headerlink" title="유연하고 재사용 가능한 협력"></a>유연하고 재사용 가능한 협력</h3><p>역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. </p><p><strong>역할은 다른 것으로 교체할 수 있는 책임의 집합이다.</strong></p><img src="/2020/01/28/objects-03/image-20200204224951119.png" alt="image-20200204224951119" style="zoom:50%;"><p> 역할은 두 종류의 구체적인 객체를 포괄하는 <strong>추상화</strong> </p><p><strong>요점</strong></p><p>동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것. </p><h3 id="객체-대-역할"><a href="#객체-대-역할" class="headerlink" title="객체 대 역할"></a>객체 대 역할</h3><p>협력에 적합한 책임을 수행하는 대상이 한 종류라면 객체로 간주한다. </p><p>여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다. </p><img src="/2020/01/28/objects-03/image-20200204225615334.png" alt="image-20200204225615334" style="zoom:50%;"><h3 id="역할과-추상화"><a href="#역할과-추상화" class="headerlink" title="역할과 추상화"></a>역할과 추상화</h3><p>추상화를 이용한 설계가 가질 수 있는 장점</p><ol><li><p>추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화 할수 있다. </p><ul><li>너무 세부적인 사항으로 인해 객체들 사이의 핵심적인 관계와 관련된 큰 그림을 파악하는 것을 방해하기에 추상화 계층을 이용</li><li>세부사항</li></ul><img src="/2020/01/28/objects-03/image-20200204230042904.png" alt="image-20200204230042904" style="zoom:33%;"><ul><li><p>추상화는 상황을 단순화 한다.</p><img src="/2020/01/28/objects-03/image-20200204230251691.png" alt="image-20200204230251691" style="zoom:33%;"></li></ul></li></ol><ol start="2"><li><p>설계를 유연하게 만들수 있다.</p><ul><li>협력 안에서 역할이라는 추상화를 이용하면 기존 코드를 수정하지 않고도 새로운 행동을 추가할 수 있다.</li></ul></li></ol><h3 id="배우와-배역"><a href="#배우와-배역" class="headerlink" title="배우와 배역"></a>배우와 배역</h3><p>배우가 여러 연극에 참여하면서 여러 배역을 연기 할수 있는 것처럼 객체 역시 여러 협력에 참여하면서 다양한 역할을 수행할 수 있다. </p><p>따라서 객체는 다양한 역할을 가질 수 있다. </p><p>객체는 여러 역할을 가질 수 있지만 특정한 협력에서는 하나의 역할만이 보임을 주의하라.</p><p>객체는 다수의 역할을 보유할 수 있지만 객체가 참여하는 특정 협력은 객체의 한가지 역할만 바라 볼 수 있다.</p><p>객체는 협력에 참여할 때 협력 안에서 하나의 역할로 보여진다. 객체가 다른 협력에 참여할 때는 다른 역할로 보여진다. </p><p>협력의 관점에서 동일한 역할을 수행하는 객체들은 서로 대체 가능하다. 역할은 특정한 객체의 종류를 캡슐화하기 때문에 동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chapter-03-역할-책임-협력&quot;&gt;&lt;a href=&quot;#Chapter-03-역할-책임-협력&quot; class=&quot;headerlink&quot; title=&quot;Chapter 03. 역할, 책임, 협력&quot;&gt;&lt;/a&gt;Chapter 03. 역할, 책임, 협력&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;객체지향 패러다임의 핵심&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;역할(role)&lt;/li&gt;
&lt;li&gt;책임(responsibility)&lt;/li&gt;
&lt;li&gt;협력(collaboration)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;객체지향의 본질&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;협력하는 객체들의 공동체를 창조하는 것&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;객체지향 설계의 핵심&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 나타난다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 02. 객체지향 프로그래밍</title>
    <link href="https://dschoi.github.io/2020/01/27/objects-02/"/>
    <id>https://dschoi.github.io/2020/01/27/objects-02/</id>
    <published>2020-01-27T07:19:36.000Z</published>
    <updated>2020-04-28T12:46:58.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-02-객체지향-프로그래밍"><a href="#chapter-02-객체지향-프로그래밍" class="headerlink" title="chapter 02. 객체지향 프로그래밍"></a>chapter 02. 객체지향 프로그래밍</h1><h2 id="01-영화-예매-시스템"><a href="#01-영화-예매-시스템" class="headerlink" title="01. 영화 예매 시스템"></a>01. 영화 예매 시스템</h2><h3 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h3><ul><li>영화</li><li>상영</li><li>할인 규칙<ul><li>할인 조건<ul><li>순서 조건</li><li>기간 조건</li></ul></li><li>할인 정책<ul><li>금액 할인 정책</li><li>비율 할인 정책</li></ul></li></ul></li></ul><h2 id="02-객체지향-프로그래밍을-향해"><a href="#02-객체지향-프로그래밍을-향해" class="headerlink" title="02. 객체지향 프로그래밍을 향해"></a>02. 객체지향 프로그래밍을 향해</h2><h3 id="협력-객체-클래스"><a href="#협력-객체-클래스" class="headerlink" title="협력, 객체, 클래스"></a>협력, 객체, 클래스</h3><blockquote><p>진정한 객체지향 패러다임으로서의 전환은 클래스가 아닌 객체에 초점을 맞출때 얻을수 있다.</p></blockquote><a id="more"></a><ol><li>어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라. 클래스는 공통적인 상태화 행동을 공유하는 객체들을 추상화한 것이다. </li><li>객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공통체의 일원으로 봐야한다. 객체는 홀로 존재하는 것이 아니다. 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다. 객체 지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라봐야한다.</li></ol><h3 id="도메인의-구조를-따르는-프로그램-구조"><a href="#도메인의-구조를-따르는-프로그램-구조" class="headerlink" title="도메인의 구조를 따르는 프로그램 구조"></a>도메인의 구조를 따르는 프로그램 구조</h3><p><strong>도메인</strong></p><blockquote><p>문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야</p></blockquote><img src="/2020/01/27/objects-02/image-20200127163753490.png" alt="image-20200127163753490" style="zoom:50%;"><img src="/2020/01/27/objects-02/image-20200127164105171.png" alt="image-20200127164105171" style="zoom:50%;"><h3 id="클래스-구현하기"><a href="#클래스-구현하기" class="headerlink" title="클래스 구현하기"></a>클래스 구현하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screening</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movie movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Screening</span><span class="params">(Movie movie, <span class="keyword">int</span> sequence, LocalDateTime localDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">        <span class="keyword">this</span>.localDateTime = localDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Movie <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSequence</span><span class="params">(<span class="keyword">int</span> sequence)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sequence == sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getMovieFee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie.getFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="자율적인-객체"><a href="#자율적인-객체" class="headerlink" title="자율적인 객체"></a>자율적인 객체</h4><ol><li>객체는 상태(state)와 행동(behivior)를 함께 가지는 복합적인 존재.</li><li>객체가 스스로 판단하고 행동하는 <strong>자율적인 존재</strong></li></ol><p><strong>캡슐화</strong></p><p>데이터와 기능을 객체 내부로 함께 묶는 것</p><p><strong>접근 제어(access control)</strong></p><p><strong>접근 수정자 (access modifier)</strong></p><p>캡슐화와 접근 제어는 객체를 두부분으로 나눈다. </p><ol><li>외부에서 접근가능한 부분 - <strong>퍼블릭 인터페이스(public interface)</strong></li><li>외부에서는 접근 불가능 하고 오직 내부에서만 접근 가능한 부분 - <strong>구현(implementation)</strong></li></ol><p>알아두어야 할 키워드 </p><p>*<em>인터페이스와 구현의 분리(separation of interface and implementation) 원칙 *</em></p><h4 id="프로그래머의-자유"><a href="#프로그래머의-자유" class="headerlink" title="프로그래머의 자유"></a>프로그래머의 자유</h4><p>프로그래머의 역할</p><ol><li>클래스 작성자 : 새로운 데이터 타입을 프로그램에 추가.</li><li>클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용</li></ol><p><strong>구현 은닉(implementation hiding)</strong></p><p>클래스 작성자가 숨겨놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경 가능</p><p>클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다.</p><h3 id="협력하는-객체들의-공동체"><a href="#협력하는-객체들의-공동체" class="headerlink" title="협력하는 객체들의 공동체"></a>협력하는 객체들의 공동체</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screening</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Money <span class="title">calculateFee</span><span class="params">(<span class="keyword">int</span> audienceCount)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> movie.calculateMovieFee(<span class="keyword">this</span>).time(audienceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.setin.study.objects.chapter02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Money ZERO = Money.wons(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Money</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Money <span class="title">wons</span><span class="params">(<span class="keyword">long</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(BigDecimal.valueOf(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Money <span class="title">wons</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(BigDecimal.valueOf(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">plus</span><span class="params">(Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(<span class="keyword">this</span>.amount.add(amount.amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">minus</span><span class="params">(Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(<span class="keyword">this</span>.amount.subtract(amount.amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">time</span><span class="params">(Money amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(<span class="keyword">this</span>.amount.multiply(amount.amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLessThan</span><span class="params">(Money other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount.compareTo(other.amount) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGreater</span><span class="params">(Money other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount.compareTo(other.amount) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>금액 구현을 위해 Money 타입을 생성</p><p>금액과 관련된 로직이 서로 다른곳에 중복되어 구현되는 것을 막을수 있고. 저장하는 값이 금액과 관련되어 있다는 의미를 전달해 줄수 있다. </p><p>영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하며 상호 작용한다.</p><p>이처럼 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 <strong>협력(Collaboration)</strong> 이라 한다.</p><img src="/2020/01/27/objects-02/image-20200127180628959.png" alt="image-20200127180628959" style="zoom:50%;"><h3 id="협력에-관한-짧은-이야기"><a href="#협력에-관한-짧은-이야기" class="headerlink" title="협력에 관한 짧은 이야기"></a>협력에 관한 짧은 이야기</h3><p>객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 <strong>요청(request)</strong></p><p>요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 <strong>응답(response)</strong></p><p>객체와 다른 객체와 상호 작용할 수 있는 유일한 방법은 <strong>메세지 전송(send a message)</strong></p><p>다른 객체에게 요청이 도착할 때 해당 객체가 <strong>메세지 수신(receive a message)</strong></p><p>메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정<strong>메서드(method)</strong></p><p><strong>다형성(polymorphism)</strong></p><h2 id="03-할인-요금-구하기"><a href="#03-할인-요금-구하기" class="headerlink" title="03. 할인 요금 구하기"></a>03. 할인 요금 구하기</h2><h3 id="할인-요금-계산을-위한-협력-시작하기"><a href="#할인-요금-계산을-위한-협력-시작하기" class="headerlink" title="할인 요금 계산을 위한 협력 시작하기"></a>할인 요금 계산을 위한 협력 시작하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Duration runningTime;</span><br><span class="line">    <span class="keyword">private</span> Money fee;</span><br><span class="line">    <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">calculateMovieFee</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fee.minus(discountPolicy.calculateDiscountAmount(screening));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Movie 는 할인 정책을 판단하는 코드가 존재하지 않고 discountPolicy에게 메세지를 전송할 뿐이다.</p><h3 id="할인-정책과-할인-조건"><a href="#할인-정책과-할인-조건" class="headerlink" title="할인 정책과 할인 조건"></a>할인 정책과 할인 조건</h3><p><strong>추상클래스</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DiscountCondition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DiscountPolicy</span><span class="params">(DiscountCondition ... conditions)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.conditions = Arrays.asList(conditions);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Money <span class="title">calculateDiscountAmount</span><span class="params">(Screening screening)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (DiscountCondition condition : conditions) &#123;</span><br><span class="line">             <span class="keyword">if</span>(condition.isSatisfiedBy(screening))&#123;</span><br><span class="line">                 <span class="keyword">return</span> getDiscountAmount(screening);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> Money.ZERO;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screening screening)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Template Method pattern</strong></p><p>부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodCondition</span> <span class="keyword">implements</span>  <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DayOfWeek dayOfWeek;</span><br><span class="line">    <span class="keyword">private</span> LocalTime startTime;</span><br><span class="line">    <span class="keyword">private</span> LocalTime endTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &amp;&amp;</span><br><span class="line">                startTime.compareTo(screening.getStartTime().toLocalTime()) &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                endTime.compareTo(screening.getStartTime().toLocalTime()) &gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceCondition</span> <span class="keyword">implements</span> <span class="title">DiscountCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequence;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screening.isSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmountDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Money discountAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmountDiscountPolicy</span><span class="params">(Money discountAmount, DiscountCondition... conditions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(conditions);</span><br><span class="line">        <span class="keyword">this</span>.discountAmount = discountAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discountAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercentDiscountPolicy</span> <span class="keyword">extends</span> <span class="title">DiscountPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> percent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PercentDiscountPolicy</span><span class="params">(<span class="keyword">double</span> percent, DiscountCondition... conditions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(conditions);</span><br><span class="line">        <span class="keyword">this</span>.percent = percent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Money <span class="title">getDiscountAmount</span><span class="params">(Screening screening)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screening.getMovieFee().times(percent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/01/27/objects-02/image-20200127220926117.png" alt="image-20200127220926117" style="zoom:50%;"><h3 id="할인-정책-구성하기"><a href="#할인-정책-구성하기" class="headerlink" title="할인 정책 구성하기"></a>할인 정책 구성하기</h3><p>생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Movie avatar = <span class="keyword">new</span> Movie(<span class="string">"아바타"</span>, Duration.ofMinute(<span class="number">120</span>), Money.wons(<span class="number">10000</span>), </span><br><span class="line"><span class="keyword">new</span> AmountDiscountPolicy(Money.wons(<span class="number">800</span>), </span><br><span class="line">  <span class="keyword">new</span> SequenceCondition(<span class="number">1</span>), </span><br><span class="line">  <span class="keyword">new</span> SequenceCondition(<span class="number">10</span>), </span><br><span class="line">  <span class="keyword">new</span> PeriodCondition(DayOfWeek.Monday, LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), LocalTime.of(<span class="number">11</span>, <span class="number">59</span>)), </span><br><span class="line">  <span class="keyword">new</span> PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(<span class="number">10</span>, <span class="number">0</span>), LocalTime.of(<span class="number">20</span>, <span class="number">59</span>)), </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="04-상속과-다형성"><a href="#04-상속과-다형성" class="headerlink" title="04. 상속과 다형성"></a>04. 상속과 다형성</h2><h3 id="컴파일-시간-의존성과-실행-시간-의존성"><a href="#컴파일-시간-의존성과-실행-시간-의존성" class="headerlink" title="컴파일 시간 의존성과 실행 시간 의존성"></a>컴파일 시간 의존성과 실행 시간 의존성</h3><img src="/2020/01/27/objects-02/image-20200127222013233.png" alt="image-20200127222013233" style="zoom:50%;"><p>코드의 의존성과 실행 시점의 의존성이 서로 다를수 있다.</p><p>다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.  <code>유연하고 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것</code>이다.</p><h3 id="차이에-의한-프로그래밍"><a href="#차이에-의한-프로그래밍" class="headerlink" title="차이에 의한 프로그래밍"></a>차이에 의한 프로그래밍</h3><h3 id="상속과-인터페이스"><a href="#상속과-인터페이스" class="headerlink" title="상속과 인터페이스"></a>상속과 인터페이스</h3><h3 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h3><blockquote><p>동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미</p><p>따라서… 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야한다. -&gt; 인터페이스가 동일해야한다.다형성을 구현하는 방법 </p></blockquote><p>*<em>구현 상속과 인터페이스 상속 *</em></p><blockquote><p>상속을 구현 상속과 인터페이스 상속으로 분류할 수 있다. 구현 상속을 서브클래싱이라 부르고, 인터페이스 상속을 서브타이핑이라 한다. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속</p><p>상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야 한다. 인터페이스를 재사용할 목적이 아니라 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 것이다.</p></blockquote><h3 id="인터페이스와-다형성"><a href="#인터페이스와-다형성" class="headerlink" title="인터페이스와 다형성"></a>인터페이스와 다형성</h3><p>추상클래스를 이용해 다형성을 구현했던 할인 정책과 달리 할인 조건은 구현을 공유할 필요가 없기에 인터페이스를 이용해 타입 계층을 구현했다.</p><img src="/2020/01/27/objects-02/image-20200127224059949.png" alt="image-20200127224059949" style="zoom:50%;"><h2 id="05-추상화와-유연성"><a href="#05-추상화와-유연성" class="headerlink" title="05. 추상화와 유연성"></a>05. 추상화와 유연성</h2><h3 id="추상화의-힘"><a href="#추상화의-힘" class="headerlink" title="추상화의 힘"></a>추상화의 힘</h3><h3 id="유연한-설계"><a href="#유연한-설계" class="headerlink" title="유연한 설계"></a>유연한 설계</h3><h3 id="추상-클래스와-인터페이스-트레이드오프"><a href="#추상-클래스와-인터페이스-트레이드오프" class="headerlink" title="추상 클래스와 인터페이스 트레이드오프"></a>추상 클래스와 인터페이스 트레이드오프</h3><h3 id="코드-재사용"><a href="#코드-재사용" class="headerlink" title="코드 재사용"></a>코드 재사용</h3><p>상속보다는 합성이 더 좋은 방법이라는 이야기를 많이 한다. </p><p>합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법</p><h3 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h3><p>상속은 두가지 관점에서 설계에 안좋은 영향을 끼친다.</p><ol><li>캡슐화를 위반한다는 것</li><li>설계를 유연하지 못하게 만든다는 것</li></ol><h3 id="합성"><a href="#합성" class="headerlink" title="합성"></a>합성</h3><p>합성은 상속이 가지는 두가지 문제점을 모두 해결가능하다.</p><ol><li>인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.</li><li>의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.</li></ol><p>상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다. </p><p><strong>코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다. [GOF94]</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-02-객체지향-프로그래밍&quot;&gt;&lt;a href=&quot;#chapter-02-객체지향-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;chapter 02. 객체지향 프로그래밍&quot;&gt;&lt;/a&gt;chapter 02. 객체지향 프로그래밍&lt;/h1&gt;&lt;h2 id=&quot;01-영화-예매-시스템&quot;&gt;&lt;a href=&quot;#01-영화-예매-시스템&quot; class=&quot;headerlink&quot; title=&quot;01. 영화 예매 시스템&quot;&gt;&lt;/a&gt;01. 영화 예매 시스템&lt;/h2&gt;&lt;h3 id=&quot;요구사항&quot;&gt;&lt;a href=&quot;#요구사항&quot; class=&quot;headerlink&quot; title=&quot;요구사항&quot;&gt;&lt;/a&gt;요구사항&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;영화&lt;/li&gt;
&lt;li&gt;상영&lt;/li&gt;
&lt;li&gt;할인 규칙&lt;ul&gt;
&lt;li&gt;할인 조건&lt;ul&gt;
&lt;li&gt;순서 조건&lt;/li&gt;
&lt;li&gt;기간 조건&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;할인 정책&lt;ul&gt;
&lt;li&gt;금액 할인 정책&lt;/li&gt;
&lt;li&gt;비율 할인 정책&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;02-객체지향-프로그래밍을-향해&quot;&gt;&lt;a href=&quot;#02-객체지향-프로그래밍을-향해&quot; class=&quot;headerlink&quot; title=&quot;02. 객체지향 프로그래밍을 향해&quot;&gt;&lt;/a&gt;02. 객체지향 프로그래밍을 향해&lt;/h2&gt;&lt;h3 id=&quot;협력-객체-클래스&quot;&gt;&lt;a href=&quot;#협력-객체-클래스&quot; class=&quot;headerlink&quot; title=&quot;협력, 객체, 클래스&quot;&gt;&lt;/a&gt;협력, 객체, 클래스&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;진정한 객체지향 패러다임으로서의 전환은 클래스가 아닌 객체에 초점을 맞출때 얻을수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>chapter 01. 객체 , 설계</title>
    <link href="https://dschoi.github.io/2020/01/27/objects-01/"/>
    <id>https://dschoi.github.io/2020/01/27/objects-01/</id>
    <published>2020-01-27T07:17:36.000Z</published>
    <updated>2020-04-28T12:46:44.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chapter-01-객체-설계"><a href="#chapter-01-객체-설계" class="headerlink" title="chapter 01. 객체 , 설계"></a>chapter 01. 객체 , 설계</h1><h2 id="티켓-판매-애플리케이션-구현하기"><a href="#티켓-판매-애플리케이션-구현하기" class="headerlink" title="티켓 판매 애플리케이션 구현하기"></a>티켓 판매 애플리케이션 구현하기</h2><p><img src="/2020/01/27/objects-01/image-20200127225843873.png" alt="image-20200127225843873"></p><p>애플리케이션의 핵심 클래스</p><h2 id="무엇이-문제인가"><a href="#무엇이-문제인가" class="headerlink" title="무엇이 문제인가"></a>무엇이 문제인가</h2><p>로버트 마틴은 클린 소프트웨어에서 소프트웨어 모듈이 가져야 하는 세가지 기능에 관해 설명한다. </p><blockquote><p>모든 소프트웨어 모듈에는 세 가지의 목적이 있다. 첫번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유. 두번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야한다. 모듈의 세번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야한다.</p></blockquote><a id="more"></a><p>모듈은 제대로 실행되어야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다. </p><p>하지만 앞서 작성한 프로그래밍은 변경 용이성과 읽는 사람과의 의사소통이라는 목적은 만족시키지 못한다.</p><h3 id="예상을-빗나가는-코드"><a href="#예상을-빗나가는-코드" class="headerlink" title="예상을 빗나가는 코드"></a>예상을 빗나가는 코드</h3><h3 id="변경에-취약한-코드"><a href="#변경에-취약한-코드" class="headerlink" title="변경에 취약한 코드"></a>변경에 취약한 코드</h3><p><strong>너무 많은 클래스에 의존하는 Theater</strong></p><img src="/2020/01/27/objects-01/image-20200128221434324.png" alt="image-20200128221434324" style="zoom:50%;"><p>객체사이의 <strong>의존성(dependency)</strong> 문제 .</p><p>객체 사이의 의존성이 과한 경우를 가리켜 <strong>결합도(coupling)</strong>가 높다고 말한다. </p><p>두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다. </p><p>따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.</p><h2 id="설계-개선하기"><a href="#설계-개선하기" class="headerlink" title="설계 개선하기"></a>설계 개선하기</h2><h3 id="자율성을-높이자"><a href="#자율성을-높이자" class="headerlink" title="자율성을 높이자."></a>자율성을 높이자.</h3><p>Theater가 Audience 와 TicketSeller 뿐만 아니라 Audience 소유의 Bag과 TicketSeller 가 근무하는 TicketOffice까지 접근이 가능하기에 설계를 변경하기 어렵다.</p><p>해결 방법은 Audience 와 TicketSeller 가 직접 Bag 과 TicketOffice를 처리하는 자율적인 존재가 되도록 설계를 변경.</p><p><strong>변경전</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Theater</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TicketSeller ticketSeller;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Theater</span><span class="params">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ticketSeller = ticketSeller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Audience audience)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class="line">Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class="line">audience.getBag().setTicket(ticket);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Ticket ticket =ticketSeller.getTicketOffice().getTicket();</span><br><span class="line">audience.getBag().minusAmount(ticket.getFee());</span><br><span class="line">ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class="line">audience.getBag().setTicket(ticket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>변경후</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Theater</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TicketSeller ticketSeller;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Theater</span><span class="params">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ticketSeller = ticketSeller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Audience audience)</span> </span>&#123;</span><br><span class="line">ticketSeller.sellTo(audience);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Theater의 결합도를 낮춘 설계</strong></p><img src="/2020/01/27/objects-01/image-20200128222326792.png" alt="image-20200128222326792" style="zoom:50%;"><h3 id="무엇이-개선됐는가"><a href="#무엇이-개선됐는가" class="headerlink" title="무엇이 개선됐는가?"></a>무엇이 개선됐는가?</h3><p>Audience 와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다. </p><p>Audience 와 TicketSeller의 내부구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다. </p><h3 id="어떻게-한-것인가"><a href="#어떻게-한-것인가" class="headerlink" title="어떻게 한 것인가?"></a>어떻게 한 것인가?</h3><p>판매자가 티켓을 판매하기 위해 TiketOffice를 사용하는 모든 부분을 TicketSeller로 옮기고, 관람객이 티켓을 구매하기 위해 Bag을 사용하는 부분을Audice 내부로 옮겼다. </p><p>자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것. </p><ol><li><p>변환전 </p><img src="/2020/01/27/objects-01/image-20200128223045864.png" alt="image-20200128223045864" style="zoom:40%;"></li><li><p>변환 후 </p><img src="/2020/01/27/objects-01/image-20200128223120756.png" alt="image-20200128223120756" style="zoom:50%; "></li></ol><h3 id="캡슐화와-응집도"><a href="#캡슐화와-응집도" class="headerlink" title="캡슐화와 응집도"></a>캡슐화와 응집도</h3><p>핵심!</p><p>객체 내부의 상태를 캡슐화하고 객체 간의 메시지를 통해서만 상호작용하도록 만드는 것.</p><p>밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 <strong>응집도(cohesion)</strong> 가 높다고 할수 있다.  자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출수 있을뿐더러 응집도를 높을수 있다.</p><h3 id="절차지향과-객체지향"><a href="#절차지향과-객체지향" class="headerlink" title="절차지향과 객체지향"></a>절차지향과 객체지향</h3><p><strong>절차지향 프로그래밍</strong></p><blockquote><p>프로세스와 데이터를 별도의 모듈에 위치시키는 방식</p></blockquote><p><strong>객체지향 프로그래밍(Object-Oriented Programming)</strong></p><blockquote><p>데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식</p></blockquote><p><strong>훌륭한 객체지향 설계의 핵심</strong></p><blockquote><p>캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것.</p></blockquote><h3 id="책임의-이동"><a href="#책임의-이동" class="headerlink" title="책임의 이동"></a>책임의 이동</h3><p>절차지향과 객체지향의 차이를 만드는 것은 책임의 이동(Shift of responsibility)</p><img src="/2020/01/27/objects-01/image-20200128224815211.png" alt="image-20200128224815211" style="zoom:50%;"><img src="/2020/01/27/objects-01/image-20200128224905609.png" alt="image-20200128224905609" style="zoom:50%;"><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="더-개선할-수-있다"><a href="#더-개선할-수-있다" class="headerlink" title="더 개선할 수 있다."></a>더 개선할 수 있다.</h3><p>변경을 하지만 TicketOffice -&gt; Audience로 통하는 의존성이 추가되었다.</p><ol><li>변경전 코드</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellTo</span><span class="params">(Audience audience)</span></span>&#123;</span><br><span class="line">ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>변경후 코드</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellTicketTo</span><span class="params">(Audience audience)</span></span>&#123;</span><br><span class="line">    plusAmount(audience.buy(getTicket()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변경을 하지만 TicketOffice -&gt; Audience로 통하는 의존성이 추가되었다.</p><img src="/2020/01/27/objects-01/image-20200128225638397.png" alt="image-20200128225638397" style="zoom:50%;"><img src="/2020/01/27/objects-01/image-20200128225532157.png" alt="image-20200128225532157" style="zoom:50%;"><h2 id="객체지향-설계"><a href="#객체지향-설계" class="headerlink" title="객체지향 설계"></a>객체지향 설계</h2><h3 id="설계가-왜-필요한가"><a href="#설계가-왜-필요한가" class="headerlink" title="설계가 왜 필요한가"></a>설계가 왜 필요한가</h3><blockquote><p>설계란 코드를 배치하는 것이다.</p></blockquote><h3 id="객체지향-설계-1"><a href="#객체지향-설계-1" class="headerlink" title="객체지향 설계"></a>객체지향 설계</h3><p>변경에 유연하게 다응할 수 있는 코드.</p><p>객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다. </p><p>변경 가능한 코드란 이해하기 쉬운 코드다.</p><p>훌륭한 객체지향 설계란?</p><p>협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다. 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-01-객체-설계&quot;&gt;&lt;a href=&quot;#chapter-01-객체-설계&quot; class=&quot;headerlink&quot; title=&quot;chapter 01. 객체 , 설계&quot;&gt;&lt;/a&gt;chapter 01. 객체 , 설계&lt;/h1&gt;&lt;h2 id=&quot;티켓-판매-애플리케이션-구현하기&quot;&gt;&lt;a href=&quot;#티켓-판매-애플리케이션-구현하기&quot; class=&quot;headerlink&quot; title=&quot;티켓 판매 애플리케이션 구현하기&quot;&gt;&lt;/a&gt;티켓 판매 애플리케이션 구현하기&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/01/27/objects-01/image-20200127225843873.png&quot; alt=&quot;image-20200127225843873&quot;&gt;&lt;/p&gt;&lt;p&gt;애플리케이션의 핵심 클래스&lt;/p&gt;&lt;h2 id=&quot;무엇이-문제인가&quot;&gt;&lt;a href=&quot;#무엇이-문제인가&quot; class=&quot;headerlink&quot; title=&quot;무엇이 문제인가&quot;&gt;&lt;/a&gt;무엇이 문제인가&lt;/h2&gt;&lt;p&gt;로버트 마틴은 클린 소프트웨어에서 소프트웨어 모듈이 가져야 하는 세가지 기능에 관해 설명한다. &lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;모든 소프트웨어 모듈에는 세 가지의 목적이 있다. 첫번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유. 두번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야한다. 모듈의 세번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야한다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="objects" scheme="https://dschoi.github.io/tags/objects/"/>
    
      <category term="object" scheme="https://dschoi.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>clean-architecture-26-28</title>
    <link href="https://dschoi.github.io/2019/11/17/clean-architecture-26-27/"/>
    <id>https://dschoi.github.io/2019/11/17/clean-architecture-26-27/</id>
    <published>2019-11-17T13:10:29.000Z</published>
    <updated>2020-02-23T16:18:47.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-메인-컴포넌트"><a href="#26-메인-컴포넌트" class="headerlink" title="26 메인 컴포넌트"></a>26 메인 컴포넌트</h1><h2 id="궁극전인-세부사항"><a href="#궁극전인-세부사항" class="headerlink" title="궁극전인 세부사항"></a>궁극전인 세부사항</h2><p><strong>문자열 초기화</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mian</span> <span class="keyword">implements</span> <span class="title">HtwMessageReceiver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HuntTheWumpus game;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hitPoints = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; caverns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] environments = <span class="keyword">new</span> String[] &#123;<span class="string">"bright"</span>, <span class="string">"humid"</span>, <span class="string">"dry"</span>, <span class="string">"creepy"</span>, <span class="string">"ugly"</span>, <span class="string">"foggy"</span>, <span class="string">"hot"</span>, <span class="string">"cold"</span>, <span class="string">"drafty"</span>, <span class="string">"dreadful"</span>&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] shapes = <span class="keyword">new</span> String[] &#123;<span class="string">"round"</span>, <span class="string">"square"</span>, <span class="string">"oval"</span>, <span class="string">"irregualar"</span>, <span class="string">"long"</span>, <span class="string">"craggy"</span>, <span class="string">"rough"</span>, <span class="string">"tall"</span>, <span class="string">"narrow"</span>&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] cavernTypes = <span class="keyword">new</span> String[] &#123;<span class="string">"cavern"</span>, <span class="string">"room"</span>, <span class="string">"chamber"</span>. <span class="string">"catacomb"</span>, <span class="string">"crevasse"</span>, <span class="string">"cell"</span>, <span class="string">"tunnel"</span>, <span class="string">"passageway"</span>, <span class="string">"hall"</span>, <span class="string">"expanse"</span>&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] adornments = <span class="keyword">new</span> String[] &#123;<span class="string">"smelling of sulfur"</span>, <span class="string">"with engravings on the walls"</span>, <span class="string">""</span>, <span class="string">"littered with garbage"</span> ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>*<em>Factory를 사용하여 게임을 생성 *</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">game = HtwFactory.makeGame(<span class="string">"htw.game.HuntTheWumpusFacade"</span>, <span class="keyword">new</span> Main()); <span class="comment">//factory 로 main 생성</span></span><br><span class="line">  </span><br><span class="line">  createMap(); <span class="comment">//지도 생성</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    HuntTheWumps.Command c = game.makeRestCommand(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    동서남북 등 키 를 받아스  행위 맵핑</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    c.execute(); <span class="comment">// 실행</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>맵 생성</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> nCaverns = (<span class="keyword">int</span>) (Math.random() * <span class="number">30.0</span> + <span class="number">10.0</span>);</span><br><span class="line">  <span class="keyword">while</span>(nCaverns-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    caverns.add(makeName());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">  game.addPitCavern(...);</span><br><span class="line">  game.setQuiver(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>메인은 클린 아키텍처의 가장 바깥 원이다.</strong></p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>메인을 플러그인 컴포넌트로 여기고 , 아키텍처 경계 바깥에 위치하나다고 보면 설정 관련 문제를 쉽게 해결 할 수 있다.</p><h1 id="27-‘크고-작은-모든’-서비스들"><a href="#27-‘크고-작은-모든’-서비스들" class="headerlink" title="27 ‘크고 작은 모든’ 서비스들"></a>27 ‘크고 작은 모든’ 서비스들</h1><h2 id="서비스-아키텍처"><a href="#서비스-아키텍처" class="headerlink" title="서비스 아키텍처?"></a>서비스 아키텍처?</h2><p>서비스는?</p><blockquote><p>프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.</p></blockquote><p>서비스를 사용하는 것이 아키텍처인가?</p><ul><li>아키텍처는 의존성 규칙을 준수하며 고수준의 정채을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.</li></ul><p>행위를 분리할 뿐인 서비스라면 값비싼 함수호출에 불과하며, 아키텍처관점에서 중요하다고 볼수 없다.</p><h2 id="서비스의-이점"><a href="#서비스의-이점" class="headerlink" title="서비스의 이점?"></a>서비스의 이점?</h2><p><strong>시스템을 서비스로 분리함으로 얻게되는 이점</strong></p><ol><li>서비스 사이의 결합이 확실히 분리된다.</li><li>전담팀이 서비스를 소유하고 운영한다.</li></ol><h3 id="결합-분리의-오류"><a href="#결합-분리의-오류" class="headerlink" title="결합 분리의 오류"></a>결합 분리의 오류</h3><blockquote><p> 서비스 사이의 결합이 분리된다는 점</p></blockquote><p><strong>정말일까?</strong></p><p>서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면, 이 서비스를 사용하는 모든 서비스는 반드시 변경되어야한다.</p><p>서비스들은 이 데이터 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어 버린다.</p><h3 id="개발-및-배포-독립성의-오류"><a href="#개발-및-배포-독립성의-오류" class="headerlink" title="개발 및 배포 독립성의 오류"></a>개발 및 배포 독립성의 오류</h3><blockquote><p>전담팀이 서비스를 소유하고 운영한다?</p></blockquote><p>전담팀이 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 진다.</p><p>개발 및 배포 독립성은 확장 가능한것으로 간주돈다.</p><ul><li>대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도, 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실이다.</li><li>서비스라고 항상 독립적으로 개발 하고, 배포하며, 운영할수 있는 것은 아니다. 데이터나 행위에서 어느정도 결합되어 있다면 결합정도에 맞게 , 개발, 배포, 운영을 조정해야한다.</li></ul><h2 id="야옹이-문제"><a href="#야옹이-문제" class="headerlink" title="야옹이 문제"></a>야옹이 문제</h2><img src="/2019/11/17/clean-architecture-26-27/image-20191117231451657.png" alt="image-20191117231451657" style="zoom:50%;"><p>Micro service</p><ul><li>Taxi UI : 고객 서비스 담당</li><li>Taxi Finder : TaxiSupplier의 현황을 검토하여 사용자에게 적합한 택시 후보들을 선별</li><li>TaxiSelector : 사용자가 지정한 비용, 시간, 고급 여부 등의 조건을 기초로 후보 택시중 적합한 택시를 선택</li><li>TaxiDisplatcher : 해당 택시에 배차 지시</li></ul><p>고양이를 배달해달라니 !!!</p><p>고양이를 배달하려면 위 서비스들 다 변경해야한다.</p><p>횡단 관심사가 지닌 문제다.</p><h2 id="객체가-구출하다"><a href="#객체가-구출하다" class="headerlink" title="객체가 구출하다"></a>객체가 구출하다</h2><p>다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함.</p><ul><li>배차에 특화된 로직은 Rides</li><li>야옹이에 대한 신규 기능은 Kittens</li></ul><p>위 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메소드나 전략 패턴등을 이용해서 오버라이드한다.</p><p>Rides 와 Kittens 가 의존성 규칙을 준수한다는 점을 주목하자.</p><img src="/2019/11/17/clean-architecture-26-27/image-20191117231103861.png" alt="image-20191117231103861" style="zoom:50%;"><h2 id="컴포넌트-기반-서비스"><a href="#컴포넌트-기반-서비스" class="headerlink" title="컴포넌트 기반 서비스"></a>컴포넌트 기반 서비스</h2><p><strong>자바의 경우</strong></p><p>서비스를 하나이상의 jar 파일에 포함되는 추상 클래스들의 집합이라고 보면,  </p><ol><li>새로운 기능 추가 혹은 기능 확장은 새로운 jar 파일로 만든다. </li><li>이때 새로운 jar 파일을 구성하는 클래스들은 기존 jar 파일에 정의된 추상 클래스들을 확장해서 만들어진다. </li><li>그러면 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 새로운 jar 파일만 추가하면 된다.</li><li>새로운 기능 추가는 개방 폐쇄 원칙을 준수하게 된다.</li></ol><img src="/2019/11/17/clean-architecture-26-27/image-20191117231028826.png" alt="image-20191117231028826" style="zoom:50%;"><h2 id="횡단-관심사"><a href="#횡단-관심사" class="headerlink" title="횡단 관심사"></a>횡단 관심사</h2><p>아키텍처 경계가 서비스 사이에 있지 않다는 사실.</p><p>서비스를 관통하며 , 서비스를 컴포넌트 단위로 분할한다.</p><p>모든 시스템이 직면하는 횡단관심사를 처리하려면 </p><p><strong>서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.</strong></p><img src="/2019/11/17/clean-architecture-26-27/image-20191117230927372.png" alt="image-20191117230927372" style="zoom:50%;"><h2 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h2><p>서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.</p><p>시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.</p><p>서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들수있다.</p><p>서비스는 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수 있다.</p><p>서비스는 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을때도 있다.</p><h1 id="28-테스트-경계"><a href="#28-테스트-경계" class="headerlink" title="28. 테스트 경계"></a>28. 테스트 경계</h1><h2 id="시스템-컴포넌트의-테스트"><a href="#시스템-컴포넌트의-테스트" class="headerlink" title="시스템 컴포넌트의 테스트"></a>시스템 컴포넌트의 테스트</h2><ul><li>인수테스트</li><li>기능테스트</li><li>cucumber 테스트<ul><li><a href="https://velog.io/@clarekang/cucumber-kr-login" target="_blank" rel="noopener">https://velog.io/@clarekang/cucumber-kr-login</a></li></ul></li><li>TDD 테스트 (Test Driven Development)</li><li>BDD 테스트 (Behavior-Driven Development)<ul><li><a href="https://blog.aliencube.org/ko/2014/04/02/differences-between-bdd-and-tdd/" target="_blank" rel="noopener">https://blog.aliencube.org/ko/2014/04/02/differences-between-bdd-and-tdd/</a></li></ul></li><li>컴포넌트 테스트</li></ul><p><strong>Test ?</strong></p><ul><li>의존성 규칙을 따른다.</li><li>세부적이며 구체적인 것으로 의존성은 항상 테스트 대상이 되는 코드를 향한다.</li><li>아키텍처에서 가장 바깥쪽 원이다.</li><li>테스트는 독립적으로 배포가능하다.</li><li>시스템 컴포넌트 중 가장 고립되어있다.</li></ul><h2 id="테스트를-고려한-설계"><a href="#테스트를-고려한-설계" class="headerlink" title="테스트를 고려한 설계"></a>테스트를 고려한 설계</h2><p>테스트가 지닌 고립성이 테스트는 대체로 배포하지 않는 다는 사실과 어우러지며, 테스트가 시스템의 설계 범위 밖에 있다고 여겨지나 이 관점은 치명적인 오류가 있다.</p><p>테스트와 시스템이 잘 통합되지 않으면 </p><ul><li>테스트는 깨지기 쉽다.</li><li>시스템은 뻣뻣해져 변경하기 어려워진다.</li></ul><p><strong>결합</strong></p><p>시스템에 강력한 결합된 테스트가 변경</p><ul><li>시스템 공통 컴포넌트가 변경되면 수백, 수천개의 테스트가 망가진다.</li><li>깨지기 쉬운 테스트 문제(Fragile Tests Problem)</li></ul><p><strong>문제 해결 방법</strong></p><p>테스트를 고려해서 설계해야함.</p><ul><li>변동성이 있는 것에 의존하지 말라. GUI 는 변동성이 크다.</li><li>GUI를 사용하지 않고 업무 규칙을 테스트 할 수 있게 해야한다.</li></ul><h2 id="테스트-API"><a href="#테스트-API" class="headerlink" title="테스트 API"></a>테스트 API</h2><p>테스트가 모든 업무 규칙을 검증하는데 사용할 수 있도록 특화된 API 를 만들면 된다. </p><p>이러한 API 는 보안 제약사항을 무시할 수 있고, 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 갖에하는 강력한 힘들 지녀야만 한다. 이 API는 사용자 인터페이스가 사용하는 인터렉터 와 인터페이스 어댑터들의 상위 집합이 될 것이다,</p><p>테스트 API 는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.</p><p>단순히 테스트를 UI에서 분리하는 것이 아닌, 애플리케이션 구조로부터 결합을 분리하는게 목표다.</p><p><strong>구조적 결합</strong></p><blockquote><p> 테스트 결합 중 가장 강하며, 가장 은밀하게 퍼져 나가는 유형</p></blockquote><p><strong>보안</strong></p><blockquote><p> 테스트 api 를 운영에 배포하면 위험에 처할 수 있다. </p></blockquote><p>위험을 피하기 위해 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할수 있는 컴포넌트로 분리해야한다.</p><h2 id="결론-2"><a href="#결론-2" class="headerlink" title="결론"></a>결론</h2><blockquote><p> 테스트는 시스템 외부에 있지 않고 시스템의 일부이다.</p></blockquote><p>테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있다.</p><p>이러한 테스트는 유지보수하기 어렵기에 결국 버려지게 된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;26-메인-컴포넌트&quot;&gt;&lt;a href=&quot;#26-메인-컴포넌트&quot; class=&quot;headerlink&quot; title=&quot;26 메인 컴포넌트&quot;&gt;&lt;/a&gt;26 메인 컴포넌트&lt;/h1&gt;&lt;h2 id=&quot;궁극전인-세부사항&quot;&gt;&lt;a href=&quot;#궁극전인-세부사항&quot; class=&quot;headerlink&quot; title=&quot;궁극전인 세부사항&quot;&gt;&lt;/a&gt;궁극전인 세부사항&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;문자열 초기화&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Mian&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HtwMessageReceiver&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; HuntTheWumpus game;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hitPoints = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; caverns = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String[] environments = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;bright&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;humid&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dry&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;creepy&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ugly&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;foggy&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;hot&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;cold&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;drafty&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dreadful&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String[] shapes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;round&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;square&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;oval&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;irregualar&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;long&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;craggy&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;rough&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;tall&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;narrow&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String[] cavernTypes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;cavern&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;room&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;chamber&quot;&lt;/span&gt;. &lt;span class=&quot;string&quot;&gt;&quot;catacomb&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;crevasse&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;cell&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;tunnel&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;passageway&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;hall&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;expanse&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String[] adornments = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;smelling of sulfur&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;with engravings on the walls&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;littered with garbage&quot;&lt;/span&gt; ... &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>5부 아키텍처 22장 ~ 25장</title>
    <link href="https://dschoi.github.io/2019/11/11/clean-architecture-22-25/"/>
    <id>https://dschoi.github.io/2019/11/11/clean-architecture-22-25/</id>
    <published>2019-11-11T11:11:19.000Z</published>
    <updated>2020-02-23T16:18:47.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22장-클린아키텍처"><a href="#22장-클린아키텍처" class="headerlink" title="22장 클린아키텍처"></a>22장 클린아키텍처</h1><p><strong>시스템 아키텍처와 관련된 여러가지 아이디어</strong></p><ul><li>육각형 아키텍처 (Hexagonal Architecture)</li><li>DCI(Data Context and Interaction)</li><li>BCE (Boundary-Control-Entity)</li></ul><p><strong>위 아키텍처의 목표?</strong></p><ul><li>관심사의 분리<ul><li>소프트웨어를 계층으로 분리함으로써 관심사의 분리 목표를 달성</li><li>최소한 업무 규칙을 위한 계층과, 사용자와 시스템인터페이스를 위한 또 다른 계층 하나를 포함해야한다.</li></ul></li></ul><a id="more"></a><p><strong>특성</strong></p><ul><li>프레임워크 독립성</li><li>테스트 용이성</li><li>UI 독립성</li><li>데이터베이스 독립성</li><li>모든 외부 에이전시에 대한 독립성</li></ul><img src="/2019/11/11/clean-architecture-22-25/the-clean-architecture.jpg" alt="The Clean Architecture의 다이어그램" style="zoom:67%;"><ul><li>참고 :    <a href="https://medium.com/@erish/python-django-clean-architecture-연구하기-591d7a555059" target="_blank" rel="noopener">https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059</a></li></ul><h2 id="의존성-규칙"><a href="#의존성-규칙" class="headerlink" title="의존성 규칙"></a>의존성 규칙</h2><blockquote><p>소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.</p></blockquote><ul><li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.</li><li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안된다.</li></ul><h3 id="엔티티"><a href="#엔티티" class="headerlink" title="엔티티"></a>엔티티</h3><blockquote><p>전사적인 핵심 업무 규칙을 캡슐화 한것</p></blockquote><p>메서드를 가지는 객체이거나 데이터 구조와 함수의 집합일수도 있다.</p><p>외부의 무엇인가가 변경되더라도 엔티티가 변경될 가능성은 적다.</p><p>특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.</p><h3 id="유스케이스"><a href="#유스케이스" class="headerlink" title="유스케이스"></a>유스케이스</h3><blockquote><p>애플리케이션에 특화된 업무 규칙을 포함</p></blockquote><p>시스템의 모든 유스케이스를 캡슐화 하고 구현</p><p>엔티티로 들어오고 나가는 데이터 흐름을 조정</p><p>유스케이스에서 발생한 변경이 엔티티에 영향을 줘서는 안된다.</p><h3 id="인터페이스-어댑터-Interface-Adaptor"><a href="#인터페이스-어댑터-Interface-Adaptor" class="headerlink" title="인터페이스 어댑터(Interface Adaptor)"></a>인터페이스 어댑터(Interface Adaptor)</h3><p>일련의 어댑터들로 구성</p><p>프레젠터, 뷰, 컨트롤러는 인터페이스 어댑터 계층에 속한다.</p><p>데이터를 엔티티나 유스케이스형식에서 영속성용으로 사용중인 임의의 프레임워크(데이터베이스)가 이용하기 편리한 형식으로 변환한다.</p><p>데이터베이스에 대해 알아서는 안된다. </p><h3 id="프레임워크와-드라이버"><a href="#프레임워크와-드라이버" class="headerlink" title="프레임워크와 드라이버"></a>프레임워크와 드라이버</h3><p>이 계층에서는 안쪽원과 통신하기 위한 접합 코드 외에는 특별히 더 작성할 코드가 많지 않다.</p><p>모든 세부사항이 위치하는 곳</p><p><strong>세부사항</strong></p><ul><li>웹</li><li>데이터베이스</li></ul><blockquote><p> 세부사항을 외부에 위치시켜서 피해를 최소화해야함.</p></blockquote><h3 id="원은-네-개여야만-하나"><a href="#원은-네-개여야만-하나" class="headerlink" title="원은 네 개여야만 하나?"></a>원은 네 개여야만 하나?</h3><p>위 네개의 원은 개념을 설명하기 위한 예시일뿐 더 많은 원이 필요할 수 있다. </p><p>하지만 <code>의존성 규칙</code> 은 적용되어야한다. </p><ul><li><p>소스코드 의존성은 항상 안쪽을 향한다.</p></li><li><p>안족으로 이동할수록 추상화와 정책의 수준은 높아진다. </p></li><li><p>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.</p></li></ul><blockquote><p>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.</p></blockquote><p><strong>가장 안쪽 원</strong></p><p>가장 범용적이며 높은 수준을 가진다.</p><h3 id="경계-횡단하기"><a href="#경계-횡단하기" class="headerlink" title="경계 횡단하기"></a>경계 횡단하기</h3><p><img src="/2019/11/11/clean-architecture-22-25/image-20191111224420543.png" alt="image-20191111224420543"></p><p>컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 예제</p><p><strong>제어 흐름</strong></p><p>컨트롤러 -&gt; 유스케이스 -&gt; 프레젠터</p><p><strong>의존성</strong></p><ul><li><p>컨트롤러 -&gt; 유스케이스</p></li><li><p>프레젠터 -&gt; 유스케이스</p></li></ul><p><strong>의존성 역전원칙</strong></p><p>제어흐름과 의존성의 방향이 반대여야하나는 경우</p><p><strong>아키텍처 경계횡단시</strong></p><p>동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.</p><h3 id="경계를-횡단하는-데이터는-어떤-모습인가"><a href="#경계를-횡단하는-데이터는-어떤-모습인가" class="headerlink" title="경계를 횡단하는 데이터는 어떤 모습인가?"></a>경계를 횡단하는 데이터는 어떤 모습인가?</h3><ul><li>기본적인 구조체</li><li>데이터 전송 객체(Data Transfer Object)</li><li>간단한 인자</li><li>해시맵</li></ul><p><strong>중요한 점</strong></p><p>격리되어 있는 데이터 구조가 경계를 가로질러 전달된다는 점</p><p>경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.</p><h2 id="전형적인-시나리오"><a href="#전형적인-시나리오" class="headerlink" title="전형적인 시나리오"></a>전형적인 시나리오</h2><p><img src="/2019/11/11/clean-architecture-22-25/image-20191111230636691.png" alt="image-20191111230636691"></p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다. 데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할수 있다.</p><h1 id="23장-프레전터와-험블-객체"><a href="#23장-프레전터와-험블-객체" class="headerlink" title="23장 프레전터와 험블 객체"></a>23장 프레전터와 험블 객체</h1><h2 id="험블객체-패턴"><a href="#험블객체-패턴" class="headerlink" title="험블객체 패턴"></a>험블객체 패턴</h2><blockquote><p>테스트 하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법</p></blockquote><p><strong>험블 객체 패턴</strong> </p><ol><li><p>행위들을 두 개의 모듈로 분리.</p></li><li><p>둘 중 하나가 험블이다. </p></li><li><p>가장 기본적인 본질은 남기고 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.</p></li></ol><h2 id="프레젠터와-뷰"><a href="#프레젠터와-뷰" class="headerlink" title="프레젠터와 뷰"></a>프레젠터와 뷰</h2><p><strong>뷰</strong></p><blockquote><p>험블 객체이고 테스트하기 어렵다.</p></blockquote><p><strong>프레젠터</strong></p><blockquote><p> 애플리케이션으로부터 데이터를 받아 화면에 표시할 수 있는 포맷으로 만드는 것 </p></blockquote><h2 id="테스트와-아키텍처"><a href="#테스트와-아키텍처" class="headerlink" title="테스트와 아키텍처"></a>테스트와 아키텍처</h2><p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성.</p><p>험블 객체 패턴이 좋은 예</p><p>행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의되기 때문이다.</p><p>프레젠터와 뷰 사이의 경계가 이러한 경계중 하나이다. </p><h2 id="데이터베이스-게이트웨이"><a href="#데이터베이스-게이트웨이" class="headerlink" title="데이터베이스 게이트웨이"></a>데이터베이스 게이트웨이</h2><p>유스케이스 계층과 데ㅣ터베이스 사이에 데이터 베이스 게이트웨이가 존재.</p><p>데이터베이스 게이트웨이트</p><ul><li>다형적 인터페이스</li><li>애플리케이션이 데이터 베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함.</li></ul><p>데이터베이스 게이트웨이 인터페이스 구현체 는 데이터베이스 계층에 위치하고 이 구현체는 험블객체이다.</p><h2 id="데이터-매퍼"><a href="#데이터-매퍼" class="headerlink" title="데이터 매퍼"></a>데이터 매퍼</h2><p>객체 관계매퍼는 존재하지 않는다.</p><p>객체는 단순히 오퍼레이션의 집합이다.</p><p>ORM 보다는 데이터 매퍼라 부른게 맞다.</p><p>ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 험블 객체 경계를 형성한다.</p><h2 id="서비스-리스너"><a href="#서비스-리스너" class="headerlink" title="서비스 리스너"></a>서비스 리스너</h2><p>서비스 리스너는 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할수 있게 간단한 데이터 구조로 포맷을 변경한다. 그 후 데이터 구조는 서비스 경계를 가로질러서 내부로 전달된다.</p><h2 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h2><p>각 아키텍처 경계마다 경계 가까이 있는 험블 객체 패턴을 발견할수 있었다.</p><ul><li>프레젠터</li><li>데이터베이스 게이트웨이 인터페이스 구현체</li><li>ORM</li></ul><p>아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일수 있다.</p><h1 id="24장-부분적-경계"><a href="#24장-부분적-경계" class="headerlink" title="24장 부분적 경계"></a>24장 부분적 경계</h1><p><strong>YAGNI</strong> (You Aren’t Going to Need It)</p><blockquote><p>너는 그게 필요하지 않아!  -&gt;&gt; “필요한 작업만 해라”</p></blockquote><p>##부분적 경계</p><h3 id="마지막-단계를-건너뛰기"><a href="#마지막-단계를-건너뛰기" class="headerlink" title="마지막 단계를 건너뛰기"></a>마지막 단계를 건너뛰기</h3><p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행 후, 단일 컴포넌트로 모아만 두는 것.</p><p><strong>장점</strong></p><ul><li>다수의 컴포넌트를 관리하는 작업이 필요없다.</li><li>버전 번호도 필요없다.</li><li>배포 관리 부담도 없다.</li></ul><p><strong>단점</strong></p><blockquote><p>완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.</p></blockquote><h3 id="일차원-경계"><a href="#일차원-경계" class="headerlink" title="일차원 경계"></a>일차원 경계</h3><p>전략패턴</p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073603255.png" alt="image-20191114073603255" style="zoom:50%;"><h3 id="퍼사드"><a href="#퍼사드" class="headerlink" title="퍼사드"></a>퍼사드</h3><p>퍼사드 패턴</p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073455909.png" alt="image-20191114073455909" style="zoom:50%;"><h2 id="결론-2"><a href="#결론-2" class="headerlink" title="결론"></a>결론</h2><p>부분적 경계 세가지 방법들은 나름의 비용과 장점을 지닌다.</p><p>각 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다르다..</p><p>아키텍처 경계가 언제, 어디에 존재해야 할지 , 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역활이다.</p><h1 id="25장-계층과-경계"><a href="#25장-계층과-경계" class="headerlink" title="25장 계층과 경계"></a>25장 계층과 경계</h1><h2 id="움퍼스-사냥-게임"><a href="#움퍼스-사냥-게임" class="headerlink" title="움퍼스 사냥 게임"></a>움퍼스 사냥 게임</h2><img src="/2019/11/11/clean-architecture-22-25/image-20191114074620616.png" alt="image-20191114074620616" style="zoom:50%;"><img src="/2019/11/11/clean-architecture-22-25/image-20191114074640787.png" alt="image-20191114074640787" style="zoom:50%;"><h2 id="클린-아키텍처"><a href="#클린-아키텍처" class="headerlink" title="클린 아키텍처?"></a>클린 아키텍처?</h2><p><strong>개선된 다이어그램</strong></p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073656634.png" alt="image-20191114073656634" style="zoom:50%;"><p><strong>단순화된 다이어그램</strong></p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073732060.png" alt="image-20191114073732060" style="zoom:50%;"><h2 id="흐름-횡단하기"><a href="#흐름-횡단하기" class="headerlink" title="흐름 횡단하기"></a>흐름 횡단하기</h2><p><strong>흐름 횡단하기</strong></p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073752080.png" alt="image-20191114073752080" style="zoom:50%;"><h2 id="흐름-분리하기"><a href="#흐름-분리하기" class="headerlink" title="흐름 분리하기"></a>흐름 분리하기</h2><img src="/2019/11/11/clean-architecture-22-25/image-20191114073825274.png" alt="image-20191114073825274" style="zoom:50%;"><p><strong>마이크로서비스 api 추가하기</strong></p><img src="/2019/11/11/clean-architecture-22-25/image-20191114073913551.png" alt="image-20191114073913551" style="zoom:50%;"><h2 id="결론-3"><a href="#결론-3" class="headerlink" title="결론"></a>결론</h2><p>아키텍처 경계는 어디에나 존재한다.</p><p>경계를 제대로 구현하려면 비용이 많이든다.</p><p>경계가 무시되고 나중에 다시 추가하려면 추가비용이 크다.</p><p>추상화가 필요하다고 미리 예측해서는 안된다. (YAGNI)</p><p><code>오버 엔지니어링이 언더 엔지니어링보다 나쁠때가 훨씬 많다.</code></p><p><strong>목표</strong></p><p>경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현하는 것</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;22장-클린아키텍처&quot;&gt;&lt;a href=&quot;#22장-클린아키텍처&quot; class=&quot;headerlink&quot; title=&quot;22장 클린아키텍처&quot;&gt;&lt;/a&gt;22장 클린아키텍처&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;시스템 아키텍처와 관련된 여러가지 아이디어&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;육각형 아키텍처 (Hexagonal Architecture)&lt;/li&gt;
&lt;li&gt;DCI(Data Context and Interaction)&lt;/li&gt;
&lt;li&gt;BCE (Boundary-Control-Entity)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;위 아키텍처의 목표?&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;관심사의 분리&lt;ul&gt;
&lt;li&gt;소프트웨어를 계층으로 분리함으로써 관심사의 분리 목표를 달성&lt;/li&gt;
&lt;li&gt;최소한 업무 규칙을 위한 계층과, 사용자와 시스템인터페이스를 위한 또 다른 계층 하나를 포함해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>5부 아키텍처 18장 ~ 21장</title>
    <link href="https://dschoi.github.io/2019/11/03/clean-architecture-18-20/"/>
    <id>https://dschoi.github.io/2019/11/03/clean-architecture-18-20/</id>
    <published>2019-11-03T09:07:19.000Z</published>
    <updated>2020-02-23T16:18:47.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5부-아키텍처"><a href="#5부-아키텍처" class="headerlink" title="5부 아키텍처"></a>5부 아키텍처</h1><h2 id="18장-경계-해부학"><a href="#18장-경계-해부학" class="headerlink" title="18장 경계 해부학"></a>18장 경계 해부학</h2><blockquote><p>시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.</p></blockquote><h3 id="경계횡단하기"><a href="#경계횡단하기" class="headerlink" title="경계횡단하기"></a>경계횡단하기</h3><p>‘런타임에 경계를 횡단한다’ 함은 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.<br>적절한 위치에서 경계를 횡단하게 하는 비결은 <code>소스 코드 의존성 관리</code></p><a id="more"></a><p><strong>why Source Code</strong></p><p>소스 코드 모듈이 변경되면 의존하는 다른 소스 코드 모듈도 변경되거나, 다시 컴파일해서 새로 배포해야 할지도 모르기 때문.</p><p>경계는 이러한 <strong>변경이 전파되는 것을 막는 방화벽</strong>을 구축하고 관리하는 수단</p><h3 id="두려운-단일체"><a href="#두려운-단일체" class="headerlink" title="두려운 단일체"></a>두려운 단일체</h3><p>배포 관점에선 단일체(monolith) :  실행가능한 jar, 단일 exe 파일로 묶인 일련의 .net 바이너리등</p><p>단일체는 경계가 드러나지 않음 </p><blockquote><p>단일체는 컴포넌트 수준으로 분리되지 않으므로, 배포할 때 개별 컴포넌트를 배포하는 대신 커다란 하나의 파일을 배포한다. 따라서 경계가 드러나지 않는다.</p></blockquote><p>경계가 드러나지 않더라도 경계가 실제로 존재하지 않거나 , 경계가 무의미한 것은 아니다. </p><p>최종적으로는 정적으로 링크된 단일 실행파일이더라도 그 안의 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 일은 가치 있는 일이다.</p><ul><li>가장 단순한 형태의 경계 횡단 <ul><li>저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출</li></ul></li></ul><img src="/2019/11/03/clean-architecture-18-20/image-20191103183037474.png" alt="image-20191103183037474" style="zoom:50%;"><ul><li>고수준 클라이언트가 저수준 서비스를 호출할때</li></ul><img src="/2019/11/03/clean-architecture-18-20/image-20191103183819797.png" alt="image-20191103183819797" style="zoom:50%;"><p>모노리틱 구조의 실행파일이라도 규칙적으로 구조를 분리하면 프로젝트를 개발 , 테스트, 배포하는 작업에 큰 도움이 된다.</p><p>단일체에서 컴포넌트 간 통신은 매우 빠르고 값싸다. 통신은 전형적인 함수 호출이기 때문이다.</p><h3 id="배포형-컴포넌트"><a href="#배포형-컴포넌트" class="headerlink" title="배포형 컴포넌트"></a>배포형 컴포넌트</h3><p>아키텍처의 경계가 물리적으로 드러나는 경우: 동적 링크 라이브러리</p><p>Ex) .net dll, 자바 jar 파일, 루비 gem 등</p><p>컴포넌트를 dll, jar 파일 형태로 배포하면 따로 컴파일 하지 않아도 사용가능하다. 이는 배포 수준 결합 분리 모드에 해당한다, 배포 작업은 단순히 이들 배포 가능한 단위를 좀 더 편안한 형태로 묶는 일에 지나지 않는다. War 파일이나 directory 형태.</p><p>배포형 컴포넌트의 경계를 가로지르는 통신은 함수 호출이므로 매우 값싸다. 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴수 있지만 대체로 이들 경계를 가로지르는 통신은 매우 빈번할 수 있을것이다.</p><h3 id="스레드"><a href="#스레드" class="headerlink" title="스레드"></a>스레드</h3><p>단일체와 배포형 컴포넌트 모두 스레드를 활용할 수 있다. 스레드는 실행 계획과 순서를 체계화 하는 방법에 가깝다. </p><p><a href="https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html" target="_blank" rel="noopener">https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html</a></p><h3 id="로컬-프로세스"><a href="#로컬-프로세스" class="headerlink" title="로컬 프로세스"></a>로컬 프로세스</h3><p>물리적 형태를 띄는 아키텍처 경계로 로컬 프로세스가 있다. </p><p><strong>로컬 프로세스간 통신</strong></p><ul><li>소켓, 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 통신</li></ul><p><strong>로컬 프로세스 간 분리 전략</strong></p><ul><li>소스 코드 의존성의 화살표는 단일체나 바이너리 컴포넌트와 동일한 방향으로 경계를 횡단.</li><li><code>항상 고수준 컴포넌트를 향함</code></li><li>로컬 프로세스에서는 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리주소 레지스트리 조회 키를 포함해서는 안된다.</li></ul><h3 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h3><p><strong>서비스</strong>는 물리적 형태를 띄는 가장 강력한 경계</p><p><strong>서비스간 통신</strong></p><ul><li><p>모든 통신이 네트워크 통신이라 가정</p></li><li><p>함수 호출에 비해 매우 느림</p></li><li><p>지연에 따른 문제를 고수준에서 처리할 수 있어야한다.</p></li><li><p>규칙</p><ul><li><p>저수준 서비스는 고수준 서비스에 ‘플러그인’ 되어야한다.</p></li><li><p>고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(ex) url) 도 포함해서는 안된다.</p></li></ul></li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>단일체를 제외한 대다수의 시스템은 한가지 이상의 경계 전략을 사용한다.</p><p>대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.</p><h2 id="19장-정책과-수준"><a href="#19장-정책과-수준" class="headerlink" title="19장. 정책과 수준"></a>19장. 정책과 수준</h2><blockquote><p>소프트웨어 시스템이란 ? 정책을 기술 한 것</p></blockquote><p>동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다. 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴퍼넌트로 분리해야한다.</p><h3 id="수준-level"><a href="#수준-level" class="headerlink" title="수준 (level)"></a>수준 (level)</h3><p>*<em>수준 *</em><br>‘입력과 출력까지의 거리’<br>시스템의 입력과 출력 모두로 부터 멀리 위치할수록 정책의 수준은 높아진다. 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.</p><p><strong>간단한 암호화 프로그램</strong><br>번역 컴포넌트는 이 시스템에서 최고 수준의 컴포넌트인데, 입력과 출력에서부터 가장 멀리 떨어져 있기 때문이다.</p><p>image 추가.</p><p><strong>주목할 점</strong><br>데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가르키지는 않는다는 사실.</p><p><strong><em>잘못된 아키텍처</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">writeChar(translate(readChar()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>개선된 시스템 아키텍처</strong></p><img src="/2019/11/03/clean-architecture-18-20/image-20191103203651980.png" alt="image-20191103203651980" style="zoom:50%;"><ul><li>ConsoleReader 와 ConsoleWirter는 클래스로 표현<ul><li>입력과 출력에 가깝기때문에 저수준이다.</li></ul></li><li>고수준의 암호화 정책을 저수준의 입력/출력 정책으로부터 분리시킨 방식</li><li>단일 책임원칙과 공통 폐쇄 원칙에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.</li><li>고수준 정책, 입력, 출력에서부터 멀리 떨어진 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유료 변경되는 경향이 있다.</li><li>소스 코드의 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다. </li></ul><p><strong>Encrypotion</strong> 컴포넌트는 <strong>IO Devices</strong> 컴포넌트를 알지 못한다. 반변 IO Devices는 Encryption 컴포넌트에 의존적이다.</p><img src="/2019/11/03/clean-architecture-18-20/image-20191103204202662.png" alt="image-20191103204202662" style="zoom:50%;"><h3 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h3><p>정책에 대한 논의는 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.</p><h2 id="20장-업무-규칙"><a href="#20장-업무-규칙" class="headerlink" title="20장. 업무 규칙"></a>20장. 업무 규칙</h2><p><strong>업무 규칙 (Business Rule)</strong></p><blockquote><p>사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차</p></blockquote><h3 id="엔티티-Entity"><a href="#엔티티-Entity" class="headerlink" title="엔티티(Entity)"></a>엔티티(Entity)</h3><p><strong>Loan 엔티티</strong></p><p>세가지 핵심 업무 데이터를 포함하여, 데이터와 관련된 세가지 핵심 업무 규칙을 인터페이스로 제공한다.</p><img src="/2019/11/03/clean-architecture-18-20/image-20191103204717586.png" alt="image-20191103204717586" style="zoom:50%;"><h3 id="유스케이스"><a href="#유스케이스" class="headerlink" title="유스케이스"></a>유스케이스</h3><p><strong>유스케이스</strong></p><blockquote><p> 애플리케이션에 특화된 업무 규칙</p></blockquote><h4 id="유스케이스-예제"><a href="#유스케이스-예제" class="headerlink" title="유스케이스 예제"></a>유스케이스 예제</h4><hr><p><strong>신규 대출을 위한 신상정보 수집하기</strong></p><p>입력 : 이름, 주소, 생일, 운전면허 번호, 주민번호 등</p><p>출력 : 사용자 확인을 위한 동일한 정보 + 신용도</p><p><strong>기본 과정</strong></p><ol><li>이름을 받아서 검증한다.</li><li>주소, 생일, 운전면허 번호, 주민번호 등을 검증한다.</li><li>신용도를 얻는다.</li><li>신용도가 500보다 낮으면, 거절을 활성화 한다.</li><li>높으면 Customer(고객)  를 생성하고 Loan Estimation(대출 견적) 을 활성화한다.</li></ol><hr><ul><li><p>엔티티 내부의 핵심 업무 규칙을 어떻게 , 언제 호출 할지를 명시하는 규칙을 담는다.</p></li><li><p>사용자 인터페이스를 기술하지 않는다.</p></li><li><p>사용자에게 어떻게 보이는지를 설명하지 않는다.</p></li><li><p>시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와 무관하다.</p></li></ul><h3 id="요청-및-응답-모델"><a href="#요청-및-응답-모델" class="headerlink" title="요청 및 응답 모델"></a>요청 및 응답 모델</h3><p>유스케이스는 입력 데이터를 받아 출력 데이터를 생성한다. 그런데 제대로 된 유스케이스 객체라면 데이터를 사용자나 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다. </p><p>엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하려는 유혹을 받을 수 있다. 엔티티와 요청/응답 모델은 상당히 많은 데이터를 공유하므로 이러한 방식이 적합해 보일 수도 있다. </p><p>진짜 중복가 우발적 중복을 구분해야 한다. </p><ol><li>진짜 중복<ul><li>한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.</li></ul></li><li>우발적 중복(거짓된 중복)<ul><li>중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.</li></ul></li></ol><h3 id="결론-2"><a href="#결론-2" class="headerlink" title="결론"></a>결론</h3><ul><li><p>업무 규칙은 시스템이 존재하는 이유다.</p></li><li><p>업무 규칙은 핵심적인 기능이다. </p></li><li><p>업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반한다.</p></li><li><p>업무 규칙은 집안의 가보이다.</p></li><li><p>업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안되며, 원래 그대로의 모습으로 남아있어야한다.</p></li><li><p>업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야한다.</p></li></ul><h2 id="21장-소리치는-아키텍처"><a href="#21장-소리치는-아키텍처" class="headerlink" title="21장. 소리치는 아키텍처"></a>21장. 소리치는 아키텍처</h2><h3 id="아키텍처의-테마"><a href="#아키텍처의-테마" class="headerlink" title="아키텍처의 테마"></a>아키텍처의 테마</h3><p>이바 야콥슨의 저서 <object oriented software engineering> 의 부제는 유스케이스 주도 접근법(Use Case Driven Approcach)다. </object></p><ul><li>소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조</li><li>아키텍처는 프레임워크에 대한 것이 <strong>아니다.</strong></li><li>프레임워크는 사용하는 도구일뿐 아키텍처가 준수해야할 대상이 아니다.</li></ul><h3 id="아키텍처의-목적"><a href="#아키텍처의-목적" class="headerlink" title="아키텍처의 목적"></a>아키텍처의 목적</h3><p>좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합은 분리시킨다.</p><h3 id="하지만-웹은"><a href="#하지만-웹은" class="headerlink" title="하지만 웹은?"></a>하지만 웹은?</h3><p><strong>웹은 아키텍처인가?</strong><br>웹은 전달 메커니즘(입출력 장치) 이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야한다.</p><h3 id="프레임워크는-도구일뿐-삶의-방식은-아니다"><a href="#프레임워크는-도구일뿐-삶의-방식은-아니다" class="headerlink" title="프레임워크는 도구일뿐, 삶의 방식은 아니다."></a>프레임워크는 도구일뿐, 삶의 방식은 아니다.</h3><ul><li>어떻게 하면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지를 생각하라. </li><li>프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하라.</li></ul><h3 id="테스트하기-쉬운-아키텍처"><a href="#테스트하기-쉬운-아키텍처" class="headerlink" title="테스트하기 쉬운 아키텍처"></a>테스트하기 쉬운 아키텍처</h3><ul><li>단위 테스트 필요</li><li>프레임워크 , DB  등에 의존성이 있는 테스트를 피하라.</li><li>엔티티 캑체는 반드시 오래된 방식의 간단한 객체(plain old object)여야 하며 , 데이터베이스,프레임워크 등에 의존적이어서는 안된다.</li></ul><h3 id="결론-3"><a href="#결론-3" class="headerlink" title="결론"></a>결론</h3><ul><li>아키텍처는 시스템을 이야기해야하며, 프레임워크에 대해 이야기 해선 안된다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5부-아키텍처&quot;&gt;&lt;a href=&quot;#5부-아키텍처&quot; class=&quot;headerlink&quot; title=&quot;5부 아키텍처&quot;&gt;&lt;/a&gt;5부 아키텍처&lt;/h1&gt;&lt;h2 id=&quot;18장-경계-해부학&quot;&gt;&lt;a href=&quot;#18장-경계-해부학&quot; class=&quot;headerlink&quot; title=&quot;18장 경계 해부학&quot;&gt;&lt;/a&gt;18장 경계 해부학&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;경계횡단하기&quot;&gt;&lt;a href=&quot;#경계횡단하기&quot; class=&quot;headerlink&quot; title=&quot;경계횡단하기&quot;&gt;&lt;/a&gt;경계횡단하기&lt;/h3&gt;&lt;p&gt;‘런타임에 경계를 횡단한다’ 함은 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.&lt;br&gt;적절한 위치에서 경계를 횡단하게 하는 비결은 &lt;code&gt;소스 코드 의존성 관리&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>4부 컴포넌트 원칙</title>
    <link href="https://dschoi.github.io/2019/10/21/4_component_principle/"/>
    <id>https://dschoi.github.io/2019/10/21/4_component_principle/</id>
    <published>2019-10-21T09:34:32.000Z</published>
    <updated>2020-02-23T16:18:47.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-컴포넌트"><a href="#12-컴포넌트" class="headerlink" title="12. 컴포넌트"></a>12. 컴포넌트</h1><p><strong>정의</strong></p><ul><li>컴포넌트는 배포단위</li><li>시스템의 구성 요소로 배포할 수 있는 가장 작은 단위</li><li>Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어 </li></ul><h2 id="컴포넌트의-간략한-역사"><a href="#컴포넌트의-간략한-역사" class="headerlink" title="컴포넌트의 간략한 역사"></a>컴포넌트의 간략한 역사</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 200</span><br><span class="line">TLS</span><br><span class="line">  START, CLA</span><br><span class="line">  TAD BUFR</span><br><span class="line">  JMS GETSTR</span><br><span class="line">  CLA</span><br><span class="line">  TAD BUFR</span><br><span class="line">  JMS, </span><br><span class="line">  ....</span><br><span class="line">K177,177</span><br><span class="line">MCR, -15</span><br></pre></td></tr></table></figure><a id="more"></a><p> <code>*200</code> 명령어는 메모리 주소 200에 로드할 코드를 생성하라고 컴파일러에 알려준다.</p><h3 id="재배치성"><a href="#재배치성" class="headerlink" title="재배치성"></a>재배치성</h3><p>재배치가 가능한 바이너리(<code>relocatable binary</code>)</p><p>로더를 사용하여 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자.</p><p><u>링킹로더 : 프로그램을 로드하는 동시에 링크까지 수행하는 로더</u></p><h3 id="링커"><a href="#링커" class="headerlink" title="링커"></a>링커</h3><p><strong>1960 ~ 70년대 이후</strong></p><p> 프로그램에 더욱 많은 기능을 넣어 프로그램이 커지자  <strong>링킹로더</strong>가 너무 느려진다. </p><p><strong><em><code>로드</code>, <code>링커</code> 두단계로 분리</em></strong></p><p>프로그래머가 느린 부분, 링크 과정을 맡어, Linker 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.</p><p>링커는 링크가 완료된 재배치 코드를 만들어 주었고 , 그 덕분에 로더의 로딩 과정이 아주 빨라짐.</p><p><strong>1980년대</strong>  </p><p>c 와 다른 고수준 언어의 프로그램 사이즈거 더욱 커졌다.</p><p>Ex) 수십만 라인 이상의 큰 프로그램</p><p>결국 또 느려졌다. </p><h4 id="프로그램-크기와-관련된-머피의-법칙"><a href="#프로그램-크기와-관련된-머피의-법칙" class="headerlink" title="프로그램 크기와 관련된 머피의 법칙"></a>프로그램 크기와 관련된 머피의 법칙</h4><p><code>컴파일 하고 링크하는데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다.</code></p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이책에서 말하는 소프트웨어 컴포넌트다.</p><p>과거에는 초인적인 노력을 들여야 컴포넌트 플러그인 아키텍처를 적용할수 있었지만, 이제는 쉽게 사용할 수 있다.</p><h1 id="13장-컴포넌트-응집도"><a href="#13장-컴포넌트-응집도" class="headerlink" title="13장. 컴포넌트 응집도"></a>13장. 컴포넌트 응집도</h1><ul><li>REP : 재사용/릴리즈 등가 원칙 (Reuse-Relese Principle)</li><li>CCP: 공통 폐쇄 원칙 (Common-Closure Principle)</li><li>CRP: 공통 재사용 원칙(Common-Reuse Principle)</li></ul><h2 id="REP-재사용-릴리즈-등가-원칙"><a href="#REP-재사용-릴리즈-등가-원칙" class="headerlink" title="REP: 재사용/릴리즈 등가 원칙"></a>REP: 재사용/릴리즈 등가 원칙</h2><p><code>재사용의 단위는 릴리즈 단위와 같다.</code></p><p>릴리즈 단위 <a href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855" target="_blank" rel="noopener">https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855</a></p><ul><li>패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않던지 해야한다.</li></ul><h2 id="CCP-공통-폐쇄-원칙"><a href="#CCP-공통-폐쇄-원칙" class="headerlink" title="CCP: 공통 폐쇄 원칙"></a>CCP: 공통 폐쇄 원칙</h2><blockquote><p>같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야한다. 패키지에 어떤 변화가 영향을 미친다면, 그 변화는 그 패키지의 모든 클래스에 영향을 미쳐야 하고 다른 패키지에는 영향을 미치치 않아야한다.</p></blockquote><p>CCP는 SRP(단일책임원칙) 을 컴포넌트 관점에서 다시 쓴것이다. </p><p>대부분의 애플리케이션의 유지보수성(maintainablility) 은 재사용성보다 중요하다.</p><p>코드가 변경이 되어야 한다면 여러 포인트의 컴퍼넌트에서 변경이 되는 것보다는 단일 컴포넌트에서 발생하는 것이 낫다. 변경을 단일 컴포넌트로 제한할 수 있다면 <strong>해당 컴포넌트</strong>만 재배포할수 있다.</p><p>CCP 는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을것을 권장</p><p>위 원칙은 OCP(개방폐쇄원칙) 과도 밀접하게 관련되어있다. </p><p><strong>SRP와의 유사성</strong><br><code>동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.</code></p><h2 id="CRP-공통-재사용-원칙"><a href="#CRP-공통-재사용-원칙" class="headerlink" title="CRP: 공통 재사용 원칙"></a>CRP: 공통 재사용 원칙</h2><p><code>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.</code></p><blockquote><p>패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 재사용해야한다.</p></blockquote><ul><li><strong>연관된 클래스들 끼리 묶어서 군집(패키지)을 이루게 한다.</strong></li><li>연관성이 낮으면 같이 묶지 않는다</li></ul><p><strong>ISP와의 관계</strong></p><p>CRP는 인터페이스 분리원칙의 포괄적인 버전이다.<br><code>필요하지 않은 것에 의존하지 말라.</code></p><h3 id="컴포넌트-응집도에-대한-균형-다이어그램"><a href="#컴포넌트-응집도에-대한-균형-다이어그램" class="headerlink" title="컴포넌트 응집도에 대한 균형 다이어그램"></a>컴포넌트 응집도에 대한 균형 다이어그램</h3><img src="/2019/10/21/4_component_principle/13_1.png" alt="13.1결합도 원칙들의 균형 다이어그램" style="zoom:20%;"><h3 id="CCP-vs-CRP"><a href="#CCP-vs-CRP" class="headerlink" title="CCP vs CRP"></a>CCP vs CRP</h3><ul><li>CCP를 확대하면 CRP가 축소 : 전체 패키지 수가 줄어듬 : 개발 용이성</li><li>CRP를 확대하면 CCP가 축소 : 전체 패키지 수가 늘어남 : 재사용성</li><li>서로 <strong>상충</strong></li><li>ISSUE 따라서 패키지 구성은 개발 용이성 -&gt; 재사용성 으로 옮겨가면서 진화한다. </li></ul><h1 id="14-컴포넌트-결합"><a href="#14-컴포넌트-결합" class="headerlink" title="14. 컴포넌트 결합"></a>14. 컴포넌트 결합</h1><h2 id="ADP-의존성-비순환-원칙-Acycleic-Dependencies-Principle"><a href="#ADP-의존성-비순환-원칙-Acycleic-Dependencies-Principle" class="headerlink" title="ADP : 의존성 비순환 원칙(Acycleic-Dependencies Principle)"></a>ADP : 의존성 비순환 원칙(Acycleic-Dependencies Principle)</h2><blockquote><p>컴포넌트 의존성 그래프에 순환이 있어서는 안된다.</p></blockquote><h3 id="주간-빌드"><a href="#주간-빌드" class="headerlink" title="주간 빌드"></a>주간 빌드</h3><ul><li><p>주 4일 작업  + 주 1일  통합 빌드. </p></li><li><p>프로젝트가 커지며 위 복잡도가 커짐.</p><ul><li>마지막 빌드 시간이 점점 길어져 하루에 끝나지 않음</li><li>빌드를 격주로 하자라는 말이 나옴.</li></ul></li></ul><h3 id="순환-의존성-제거하기"><a href="#순환-의존성-제거하기" class="headerlink" title="순환 의존성 제거하기"></a>순환 의존성 제거하기</h3><h5 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h5><p>개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것. </p><img src="/2019/10/21/4_component_principle/image-20191023225916783.png" style="zoom:50%;"><p>위 구조는 비순환 방향 그래프</p><p>마지막 빌드 과정 </p><p>Entities -&gt; Database , Interactors -&gt; Presenters, View, Controllers, Authorizer -&gt; main</p><h4 id="순환이-컴포넌트-의존성-그래프에-미치는-영향"><a href="#순환이-컴포넌트-의존성-그래프에-미치는-영향" class="headerlink" title="순환이 컴포넌트 의존성 그래프에 미치는 영향"></a>순환이 컴포넌트 의존성 그래프에 미치는 영향</h4><img src="/2019/10/21/4_component_principle/image-20191023225931530.png" style="zoom:50%;"><ul><li>Database -&gt; Entities -&gt; Authorizer -&gt; Interactor 순으로 순환고리가 이어져 하나의 거대한 컴포넌트가 되어짐.</li></ul><h4 id="순환-끊기"><a href="#순환-끊기" class="headerlink" title="순환 끊기"></a>순환 끊기</h4><ol><li>DIP(의존성 역전원칙) 적용.</li><li>Entities 와 Autorizer가 모두 의존하는 새 컴퍼넌트를 만든다.</li></ol><h4 id="흐트러짐-Jitters"><a href="#흐트러짐-Jitters" class="headerlink" title="흐트러짐(Jitters)"></a>흐트러짐(Jitters)</h4><p>요구사항이 변경되면 컴포넌트 구조도 변경될수 있다는 사실.</p><p>어플리케이션이 성장함에 따라 의존성 구조는 점점 흐트러지고 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야한다. 순환이 발생하면 어떤 식으로든 끊어야 한다. </p><h2 id="하향식설계-top-down"><a href="#하향식설계-top-down" class="headerlink" title="하향식설계(top-down)"></a>하향식설계(top-down)</h2><ul><li>패키지 구조를 먼저 설계하면 실패할 가능성이 크다.</li><li>패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 진화해야 한다</li></ul><h2 id="SDP-안정된-의존성-원칙-Stable-Dependencies-Principle"><a href="#SDP-안정된-의존성-원칙-Stable-Dependencies-Principle" class="headerlink" title="SDP: 안정된 의존성 원칙(Stable-Dependencies Principle)"></a>SDP: 안정된 의존성 원칙(Stable-Dependencies Principle)</h2><blockquote><p>안정성의 방향으로(더 안정된 쪽에) 의존하라.</p></blockquote><ul><li>SDP가 적용된 패키지는 쉽게 변화도록 설계가 되어 있어서 <strong>변경되리라 예상할 수 있다.</strong></li></ul><h3 id="안정성"><a href="#안정성" class="headerlink" title="안정성"></a>안정성</h3><p>안정성은 변화를 만들기 위해 필요한 작업량</p><p><strong>안정된 컴포넌트</strong><br><img src="/2019/10/21/4_component_principle/image-20191023231323243.png" alt="안정된컴포넌트" style="zoom:50%;"></p><p>X는 안정적이다. 세 컴포넌트가 X에 의존하며 , 따라서 X는 변경하지 말아야 할 이유가 세가지나 되지 때문이다. 이 경우 X는 세 컴포넌트를 책임진다(responsible)라고 말한다. 반대로 X는 어디에도 의존하지 않으므로 X는 독립적이다.(independent)라고 말한다.</p><p> <strong>불안정한 컴포넌트</strong><br><img src="/2019/10/21/4_component_principle/image-20191023231412985.png" alt="불안정한 컴포넌트" style="zoom:50%;"></p><ul><li><p>Y는 3개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부요인이 3가지다. </p></li><li><p>Y는 의존적이다.</p><h3 id="안정성-지표"><a href="#안정성-지표" class="headerlink" title="안정성 지표"></a>안정성 지표</h3></li><li><p>fan-in: 안으로 들어오는 의존성.</p></li><li><p>Fan-out: 밖으로 나가는 의존성.</p></li><li><p>I(불안정성): I = Fan-out / (Fan-in + Fan-out). I=0 이면 최고로 안정된 컴포넌트라는 뜻, I=1 이면 최고로 불안정한 컴포넌트라는 뜻.</p></li></ul><h3 id="모든-컴퍼넌트가-안정적이어야-하는-것은-아니다"><a href="#모든-컴퍼넌트가-안정적이어야-하는-것은-아니다" class="headerlink" title="모든 컴퍼넌트가 안정적이어야 하는 것은 아니다."></a>모든 컴퍼넌트가 안정적이어야 하는 것은 아니다.</h3><p>만약 모든 패키지가 안정적이라면 시스템은 변경할 수 없게 될 것이다.<br>공통패키지를 이용 불안정성을 유지해서 확장가능하게 한다.</p><h2 id="SAP-안정된-추상화-원칙-Stable-Abstractions-Principle"><a href="#SAP-안정된-추상화-원칙-Stable-Abstractions-Principle" class="headerlink" title="SAP : 안정된 추상화 원칙(Stable-Abstractions Principle)"></a>SAP : 안정된 추상화 원칙(Stable-Abstractions Principle)</h2><p><code>컴포넌트는 안정된 정도만큼만 추상화되어야한다.</code></p><p>안정성과 추상성 사이의 관계를 정한다.</p><p>추상클래스(인터페이스)를 통해서 추상성과 안정성 사이의 균형을 확보<br>패키지의 성격에 따라 적절한 추상성을 확보해야한다.</p><p>SAP와 SDP 를 결합하면 컴포넌트에 대한 DIP 와 비슷하다.<br>컴포넌트는 어느 부분은 추상적이면서 다른 부분은 안정적일 수 있다. </p><h4 id="주계열"><a href="#주계열" class="headerlink" title="주계열"></a>주계열</h4><ul><li>A: 추상화 정도</li><li>I: 불안정성</li></ul><img src="/2019/10/21/4_component_principle/image-20191023233656788.png" alt="image-20191023233656788" style="zoom:30%;"><ul><li>0,0 : 안정적이고 구체적</li><li>1,1: 의존성이 없고(불안정적)추상적 : 쓸모없는 구역</li><li>1,0 &amp; 0,1 : 주계열 , 너무 추상적이지 않고 안정적이지도 않음.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;12-컴포넌트&quot;&gt;&lt;a href=&quot;#12-컴포넌트&quot; class=&quot;headerlink&quot; title=&quot;12. 컴포넌트&quot;&gt;&lt;/a&gt;12. 컴포넌트&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;컴포넌트는 배포단위&lt;/li&gt;
&lt;li&gt;시스템의 구성 요소로 배포할 수 있는 가장 작은 단위&lt;/li&gt;
&lt;li&gt;Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어 &lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;컴포넌트의-간략한-역사&quot;&gt;&lt;a href=&quot;#컴포넌트의-간략한-역사&quot; class=&quot;headerlink&quot; title=&quot;컴포넌트의 간략한 역사&quot;&gt;&lt;/a&gt;컴포넌트의 간략한 역사&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;					* 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					TLS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  START, 	CLA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				TAD BUFR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				JMS GETSTR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				CLA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				TAD BUFR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				JMS, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  				....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;K177,			177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MCR, 			-15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>클린아키텍처 3부 설계원칙</title>
    <link href="https://dschoi.github.io/2019/10/12/2019-10-12-3%EB%B6%80_%EC%84%A4%EA%B3%84%EC%9B%90%EC%B9%99/"/>
    <id>https://dschoi.github.io/2019/10/12/2019-10-12-3부_설계원칙/</id>
    <published>2019-10-12T12:00:50.000Z</published>
    <updated>2020-02-23T16:18:47.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3부-설계-원칙"><a href="#3부-설계-원칙" class="headerlink" title="3부 설계 원칙"></a>3부 설계 원칙</h1><p>좋은 소프트웨어는 깔끔한 코드<code>clean code</code> 에서 시작한다.</p><p>좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요함. 그것이  <code>SOLID</code></p><p>SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">변경에 유연하다.</span><br><span class="line">이해하기 쉽다.</span><br><span class="line">많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.</span><br></pre></td></tr></table></figure><h5 id="중간-수준이란"><a href="#중간-수준이란" class="headerlink" title="중간 수준이란?"></a>중간 수준이란?</h5><p>프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻.</p><p>코드 수준보다 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의</p><h4 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h4><ul><li><p>SRP : 단일 책임의 원칙</p><ul><li>소트트웨어 모듈은 변경의 이유가 하나여야한다.</li></ul></li><li><p>OCP : 개방-폐쇄 원칙</p><ul><li>기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템을 설계.</li></ul></li><li><p>LSP : 리스코프 치환 원칙</p><ul><li>상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들수 있으려면, 이들 구성요소는 서로 치환 가능해야한다.</li></ul></li><li><p>ISP: 인터페이스 분리 원칙</p><ul><li>사용하지 않는 것에 의존하지 않아야한다.</li></ul></li><li><p>DIP: 의존성 역전 원칙</p><ul><li>고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 의존해서는 안된다.</li></ul></li></ul><a id="more"></a>  <h2 id="7장-SRP-단일-책임-원칙"><a href="#7장-SRP-단일-책임-원칙" class="headerlink" title="7장. SRP: 단일 책임 원칙"></a>7장. SRP: 단일 책임 원칙</h2><p>단 하나의 일만 해야한다? 가 아니라 <code>단일 모듈은 변경의 이유가 하나여야한다.</code></p><p><strong>하나의 모듈은 하나의 , 오직 하나의 액터에 대해서만 책임져야 한다.</strong></p><h3 id="책임이란"><a href="#책임이란" class="headerlink" title="책임이란?"></a>책임이란?</h3><p><strong>변경을 위한 이유</strong></p><h5 id="모듈이란"><a href="#모듈이란" class="headerlink" title="모듈이란?"></a>모듈이란?</h5><ul><li>가장 단순한 정의 : 소스파일</li><li>일부 언어와 개발 환경:  함수와 데이터 구조로 구성된 응집된 집합</li></ul><h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>SRP는 가장 간단한 원칙 중 하나임과 동시에 제대로 적용하기 어려운 원칙중 하나이다.</p><p>책임들을 결합하는 것은 우리가 너무나 자연스럽게 해버리고 마는 일이다. 이런 책임을 찾고 하나씩 분리하는 것이 소프트웨어 설계에서 실제로 하는 일의 대부분이다.  이후에 논할 나머지 원칙들에서도 어떤 식으로든 이 문제로 돌아오게 된다.</p><h2 id="8장-OCP-개방-폐쇄-원칙"><a href="#8장-OCP-개방-폐쇄-원칙" class="headerlink" title="8장. OCP: 개방-폐쇄 원칙"></a>8장. OCP: 개방-폐쇄 원칙</h2><p>OCP 가 내포하는 일차적인 메커니즘은 추상화와 다형성이다.</p><p><code>소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야한다.</code></p><ol><li><p>확장에 열려있다.</p><p>모듈의 행위가 확장될 수 있음을 의미한다. 애플리케이션의 요구사항이 변경될 때 , 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장 할 수 있다. 즉 모듈이 하는 일을 변경할 수 있다.</p></li><li><p>변경에 대해 닫혀있다.</p><p>모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.</p></li></ol><p>OCP 를 따르자면 비용이 많이 든다. 적절한 추상화를 만들기 위해서는 개발 시간과 노력이 들 뿐만 아니라, 이런 추상화는 소프트웨어 설계의 복잡성을 높인다.</p><p>OCP 적용</p><p>소프트웨어를 불필요한 복잡성의 부하에서 구하려면, 한번은 속아야한다.</p><h5 id="나를-한-번-놀리면…"><a href="#나를-한-번-놀리면…" class="headerlink" title="나를 한 번 놀리면…"></a>나를 한 번 놀리면…</h5><p><code>한 번 속지 두번 속냐?</code></p><p>처음에는 코드가 변경되지 않을 것이라 생각하고 작성한다. 변경이 일어나면, 나중에 그런 종류의 변경으로부터 보호하는 추상화를 구현한다.</p><p>즉 첫번째 총알은 그냥 맞고, 그 총에서 쏘는 다른 총알에 대해서는 확실히 보호한다는 뜻이다.</p><h5 id="변경-시뮬레이션-하기"><a href="#변경-시뮬레이션-하기" class="headerlink" title="변경 시뮬레이션 하기"></a>변경 시뮬레이션 하기</h5><p>첫번째 총알을 맞기로 결정했다면, 총알이 빨리 그리고 자주 날라올수록 유리하다. 개발 과정에서 너무 멀어지기 전에 어떤 종류의 변경이 일어날 것인지 알고 싶어한다. 어떤 종류의 변경이 일어날 것인지 알기 위해 기다리는 시간이 길어질수록 추상화를 만드는 일은 어려워진다.</p><h6 id="변경-시뮬레이션-방법"><a href="#변경-시뮬레이션-방법" class="headerlink" title="변경 시뮬레이션 방법"></a>변경 시뮬레이션 방법</h6><ol><li>테스트를 먼저 작성한다.</li><li>아주 짧은 주기로 개발한다.</li><li>기반 구조보다 기능 요소를 먼저 개발하고, 자주 이 기능 요소를 이해당사자에게 보여준다.</li><li>가장 중요한 기능 요소를 먼저 개발한다.</li><li>소프트웨어를 빨리, 그리고 자주 릴리즈한다. </li></ol><h4 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h4><p>OCP 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.</p><p>이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.</p><p>어플리케이션의 모든 부분에 마구 추상화를 적용하는 것도 좋은 생각은 아니다. 그보다는 프로그램에서 자주 변경되는 부분에만 추상화를 적용하기 위한 개발자의 헌신이 필요하다. <strong>어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요하다.</strong></p><h2 id="9장-LSP-리스코프-치환-원칙"><a href="#9장-LSP-리스코프-치환-원칙" class="headerlink" title="9장. LSP: 리스코프 치환 원칙"></a>9장. LSP: 리스코프 치환 원칙</h2><p>상속의 특별한 사용을 규율하은 설계 법칙.</p><p><code>서브타입은 그것의 가반 타입으로 치환 가능해야한다.</code></p><p>1998년 바버라 리스코프가 처음 이원칙을 작성했다. </p><h3 id="LSP-위반의-간단한-예"><a href="#LSP-위반의-간단한-예" class="headerlink" title="LSP 위반의 간단한 예"></a>LSP 위반의 간단한 예</h3><p>drawShape 함수는 OCP 를 위한한다.</p><p>Square와 circle 이 shape 를 대체할 수 없는 것은 LSP 위반이며, 이 위반은 OCP 위반을 유발한다.</p><p>그러므로 LSP 위반은 잠재적인 OCP 위반이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">(<span class="keyword">final</span> Shape s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.type == Square)&#123;</span><br><span class="line">    blah blah</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.type == Circle)&#123;</span><br><span class="line">    blah blah</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="결론-2"><a href="#결론-2" class="headerlink" title="결론"></a>결론</h4><p>LSP 는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야할 수 있기 때문이다.</p><p>LSP 는 OCP를 가능하게 하는 주요 요 중 하나다. 이것은 기반 타입으로 표현된 모듈을 수정 없이도 확장 가능하게 만드는 서브타입의 치환 가능성을 말한다. 기반 타입의 계약사항은 명시적으로 강제되지 않은 경우 , 코드에서 분명하고 뚜렷해야하한다.</p><h2 id="10장-ISP-인터페이스-분리-원칙"><a href="#10장-ISP-인터페이스-분리-원칙" class="headerlink" title="10장. ISP: 인터페이스 분리 원칙"></a>10장. ISP: 인터페이스 분리 원칙</h2><p>ISP 는 ‘비대한’ 인터페이스의 단점을 해결한다. 비대한 인터페이스를 가지는 클래스는 응집력이 없는 인터페이스를 가지는 클래스다.</p><h4 id="인터페이스-분리-원칙"><a href="#인터페이스-분리-원칙" class="headerlink" title="인터페이스 분리 원칙"></a>인터페이스 분리 원칙</h4><p><code>클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제도어서는 안된다.</code></p><h4 id="결론-3"><a href="#결론-3" class="headerlink" title="결론"></a>결론</h4><p>불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠진다.</p><h2 id="11장-DIP-의존성-역전-원칙"><a href="#11장-DIP-의존성-역전-원칙" class="headerlink" title="11장. DIP: 의존성 역전 원칙"></a>11장. DIP: 의존성 역전 원칙</h2><h4 id="의존성-역전-원칙"><a href="#의존성-역전-원칙" class="headerlink" title="의존성 역전 원칙"></a>의존성 역전 원칙</h4><ol><li>상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야한다.</li><li>추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.</li></ol><p>Button 객체가 Lamp 객체를 제어하는 시스템을 설계해보자.</p><img src="https://github.com/dsChoi/dsChoi.github.io/blob/master/_posts/img/image-20191013204245701.png?raw=true" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lamp lamp;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 어떤 조건 */</span>)&#123;</span><br><span class="line">      lamp.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lamp 객체의 의존성을 역전시킴.</p><img src="https://github.com/dsChoi/dsChoi.github.io/blob/master/_posts/img/image-20191013205042370.png?raw=true" style="zoom:67%;"><h4 id="안정된-추상화"><a href="#안정된-추상화" class="headerlink" title="안정된 추상화"></a>안정된 추상화</h4><h5 id="안정된-소프트웨어-아키텍처를-구성하기-위한-코딩-실천법"><a href="#안정된-소프트웨어-아키텍처를-구성하기-위한-코딩-실천법" class="headerlink" title="안정된 소프트웨어 아키텍처를 구성하기 위한 코딩 실천법"></a>안정된 소프트웨어 아키텍처를 구성하기 위한 코딩 실천법</h5><ul><li>변동성이 큰 구체 클래스를 참조하지 말라.</li><li>변동성이 큰 구체 클래스로부터 파생하지 말라.</li><li>구체 함수를 오버라이드 하지 말라.</li><li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.</li></ul><h4 id="결론-4"><a href="#결론-4" class="headerlink" title="결론"></a>결론</h4><p>의존성은 아키텍처 경게로 추상적인 엔티티가 있는 쪽으로만 향한다. </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3부-설계-원칙&quot;&gt;&lt;a href=&quot;#3부-설계-원칙&quot; class=&quot;headerlink&quot; title=&quot;3부 설계 원칙&quot;&gt;&lt;/a&gt;3부 설계 원칙&lt;/h1&gt;&lt;p&gt;좋은 소프트웨어는 깔끔한 코드&lt;code&gt;clean code&lt;/code&gt; 에서 시작한다.&lt;/p&gt;
&lt;p&gt;좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요함. 그것이  &lt;code&gt;SOLID&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;변경에 유연하다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;이해하기 쉽다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;중간-수준이란&quot;&gt;&lt;a href=&quot;#중간-수준이란&quot; class=&quot;headerlink&quot; title=&quot;중간 수준이란?&quot;&gt;&lt;/a&gt;중간 수준이란?&lt;/h5&gt;&lt;p&gt;프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻.&lt;/p&gt;
&lt;p&gt;코드 수준보다 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의&lt;/p&gt;
&lt;h4 id=&quot;SOLID&quot;&gt;&lt;a href=&quot;#SOLID&quot; class=&quot;headerlink&quot; title=&quot;SOLID&quot;&gt;&lt;/a&gt;SOLID&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SRP : 단일 책임의 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소트트웨어 모듈은 변경의 이유가 하나여야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OCP : 개방-폐쇄 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템을 설계.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LSP : 리스코프 치환 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들수 있으려면, 이들 구성요소는 서로 치환 가능해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ISP: 인터페이스 분리 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용하지 않는 것에 의존하지 않아야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DIP: 의존성 역전 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 의존해서는 안된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>클린아키텍처-2부 벽돌부터 시작하기: 프로그래밍 패러다임</title>
    <link href="https://dschoi.github.io/2019/10/10/2019-10-10-2%EB%B6%80_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/"/>
    <id>https://dschoi.github.io/2019/10/10/2019-10-10-2부_프로그래밍_패러다임/</id>
    <published>2019-10-10T02:31:50.000Z</published>
    <updated>2020-02-23T16:18:47.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2부-벽돌부터-시작하기-프로그래밍-패러다임"><a href="#2부-벽돌부터-시작하기-프로그래밍-패러다임" class="headerlink" title="2부 벽돌부터 시작하기: 프로그래밍 패러다임"></a>2부 벽돌부터 시작하기: 프로그래밍 패러다임</h1><h2 id="3장-패러다임-개요"><a href="#3장-패러다임-개요" class="headerlink" title="3장 패러다임 개요"></a>3장 패러다임 개요</h2><ul><li><p>구조적 프로그래밍</p><ul><li><p>패러다임 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">구조적 프로그래밍은 제어흐름의 전환에 대해 규칙을 부과한다.</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>객체 지향 프로그래밍</p><ul><li><p>사실 구조적 프로그램보다 2년 앞선 1966년에 등장</p></li><li><p>패러다임</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>함수형 프로그래밍</p><ul><li><p>최근 도입시작하긴했지만 세 패러다임중 가장 먼저 등장했다. </p></li><li><p>1958년 존 매카시가 만든 람다 계산법</p></li><li><p>불변성</p><ul><li>심볼의 값이 변경되지 않는다는 개념</li></ul></li><li><p>패러다임</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>생각할 거리</p><ul><li>패러다임은 프로그래머에게 권한을 박탈한다.</li><li>패러다임은 무엇을 해야할지를 말하기보다는 <code>무엇을 해서는 안되는 지</code> 를 말해준다.</li></ul></li><li><p>결론</p><ol><li>함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.</li><li>모듈 기반의 알고리즘 사용</li><li>구조적 프로그래밍을 사용</li></ol><ul><li>세가지 패러다임과 아키텍처의 세 가지 큰 관심사?(함수, 컴퍼넌트 분리, 데이터 관리)가 어떻게 연관되는지 확인하자.    </li></ul></li></ul><a id="more"></a><h2 id="4장-구조적-프로그래밍"><a href="#4장-구조적-프로그래밍" class="headerlink" title="4장 구조적 프로그래밍"></a>4장 구조적 프로그래밍</h2><ul><li><p>증명</p><ul><li>뵘, 야코피니가 모든 프로그램을 순차, 분기, 반복이라는 세가지 구조만으로 표현할수 있다는 사실을 증명</li><li>모듈을 증명 가능하게 하는 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실.</li></ul></li><li><p>해로운 성명서</p><ul><li>1968년 데이크스트라는 ‘goto문의 해로움’ 을 CACM 에 게제</li></ul></li><li><p>기능적 분해</p><ul><li>거대한 문제 시술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.</li><li>기능은 다시 저수준의 함수들로 분해함 -&gt; 최소 단위 까지 반복가능</li><li>위 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용해 표현가능</li><li>구조적분석(<code>structured analysis</code>) 나 구조적 설계(<code>structured design</code>)  기법이 1970년대 ~ 80 년대에 인기</li><li>대규모 시스템을 모듈과 컴포넌트로 나눌수 있고, 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화 가능<ul><li>모듈 :가장 상위에 위치하는 <strong>구현의 단위</strong></li><li>컴퍼넌트 : <strong>런타임 엔티티를 참조하는 단위</strong></li><li>참조 <a href="https://imcreator.tistory.com/7" target="_blank" rel="noopener">모듈과 컴퍼넌트</a></li></ul></li></ul></li><li><p>엄밀한 증명은 없었다</p></li><li><p>과학이 구출하다</p><ul><li>과학적 방법은 반증은 가능하지만 증명은 불가능하다.</li><li>수학은 증명 가능한 서술이 참임을 입증하는 원리</li><li>과학은 증명 가능한 서술이 거짓임을 입증하는 원리</li></ul></li><li><p>테스트</p><ul><li><p>데이크스트라</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄수 없다.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>테스트에 노력을 들였다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라 여길수 있게 해준다.</p></li><li><p>거짓임을 증명하려는 테스트가 실패하면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라 여길수 있다.</p></li></ul></li><li><p>결론</p><ul><li>소프트웨어 아키텍트는 모듈, 컴퍼넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야한다.</li></ul></li></ul><h2 id="5장-객체-지향-프로그래밍"><a href="#5장-객체-지향-프로그래밍" class="headerlink" title="5장 객체 지향 프로그래밍"></a>5장 객체 지향 프로그래밍</h2><p>좋은 아키텍처를 만드는 일은 객체 지향(object-oriented) 설계 원칙을 이해하고 응용하는데서 출발</p><h3 id="OO-란"><a href="#OO-란" class="headerlink" title="OO 란?"></a>OO 란?</h3><ol><li>“데이터와 함수의 조합”</li><li>“실제 세계를 모델링하는 새로운 방법” &lt;- 얼버무리는 수준이다. </li><li>캡슐화, 상속, 다형성의 개념을 적절하게 조합한 것, 또는 OO 언어는 최소한 세가지 요소를 반드시 지원해야한다.</li></ol><h4 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화?"></a>캡슐화?</h4><ul><li>구분선 바깥에서 데이터는 은닉(private)되고, 일부 함수만이 외부에 노출(public)<h4 id="상속"><a href="#상속" class="headerlink" title="상속?"></a>상속?</h4><h4 id="다형성"><a href="#다형성" class="headerlink" title="다형성?"></a>다형성?</h4></li><li>OO 언어는 다형성을 좀더 안전하고 편리하게 사용할 수 있게 해준다.</li><li>관례를 없애주며 실수할 위험이 없다.<h5 id="의존성-역전"><a href="#의존성-역전" class="headerlink" title="의존성 역전"></a>의존성 역전</h5>소스코드 의존성의 방향은 반드시 제어흐름(<code>flow of control</code>)을 따르게 된다.<br>OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드의 의존성을 어디에서든 역전시킬 수 있다는 뜻.</li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. </p><p>OO 를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모든 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들수 있고 고수줁의 모듈과는 독립적으로 개발하고 배포할수 있다. </p><h2 id="6장-함수형-프로그래밍"><a href="#6장-함수형-프로그래밍" class="headerlink" title="6장 함수형 프로그래밍"></a>6장 함수형 프로그래밍</h2><p>함수형 프로그래밍은 알론조 처치가 1930년대에 발명한 람다 계산법에 기반한다.</p><h3 id="정수를-제곱하기"><a href="#정수를-제곱하기" class="headerlink" title="정수를 제곱하기"></a>정수를 제곱하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squint</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++)&#123;</span><br><span class="line">      System.out.println(i*i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">println</span> (<span class="name"><span class="builtin-name">take</span></span> <span class="number">25</span> (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name"><span class="builtin-name">*</span></span> x x )) (<span class="name"><span class="builtin-name">range</span></span>))))</span><br></pre></td></tr></table></figure><h3 id="가변성의-분리"><a href="#가변성의-분리" class="headerlink" title="가변성의 분리"></a>가변성의 분리</h3><p>가변 컴포넌트와 불변 컴퍼넌트로 분리</p><p>애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다. </p><p>그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.</p><h3 id="이벤트-소싱"><a href="#이벤트-소싱" class="headerlink" title="이벤트 소싱"></a>이벤트 소싱</h3><p>변수를 변경하지 않고 트랜잭션을 저장한다.</p><p>애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분</p><p>변수를 저장하지는 않는다.</p><h3 id="결론-1"><a href="#결론-1" class="headerlink" title="결론"></a>결론</h3><ul><li>구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율</li><li>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율</li><li>함수형 프로그래밍은 변수 할당에 부과되는 규율</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2부-벽돌부터-시작하기-프로그래밍-패러다임&quot;&gt;&lt;a href=&quot;#2부-벽돌부터-시작하기-프로그래밍-패러다임&quot; class=&quot;headerlink&quot; title=&quot;2부 벽돌부터 시작하기: 프로그래밍 패러다임&quot;&gt;&lt;/a&gt;2부 벽돌부터 시작하기: 프로그래밍 패러다임&lt;/h1&gt;&lt;h2 id=&quot;3장-패러다임-개요&quot;&gt;&lt;a href=&quot;#3장-패러다임-개요&quot; class=&quot;headerlink&quot; title=&quot;3장 패러다임 개요&quot;&gt;&lt;/a&gt;3장 패러다임 개요&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;구조적 프로그래밍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;패러다임 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;구조적 프로그래밍은 제어흐름의 전환에 대해 규칙을 부과한다.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;객체 지향 프로그래밍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;사실 구조적 프로그램보다 2년 앞선 1966년에 등장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;패러다임&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;함수형 프로그래밍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;최근 도입시작하긴했지만 세 패러다임중 가장 먼저 등장했다. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1958년 존 매카시가 만든 람다 계산법&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;불변성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;심볼의 값이 변경되지 않는다는 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;패러다임&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;생각할 거리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;패러다임은 프로그래머에게 권한을 박탈한다.&lt;/li&gt;
&lt;li&gt;패러다임은 무엇을 해야할지를 말하기보다는 &lt;code&gt;무엇을 해서는 안되는 지&lt;/code&gt; 를 말해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;결론&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.&lt;/li&gt;
&lt;li&gt;모듈 기반의 알고리즘 사용&lt;/li&gt;
&lt;li&gt;구조적 프로그래밍을 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;세가지 패러다임과 아키텍처의 세 가지 큰 관심사?(함수, 컴퍼넌트 분리, 데이터 관리)가 어떻게 연관되는지 확인하자.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
  <entry>
    <title>클린아키텍처 1부 목차</title>
    <link href="https://dschoi.github.io/2019/10/08/2019-10-08-%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_%EB%AA%A9%EC%B0%A8/"/>
    <id>https://dschoi.github.io/2019/10/08/2019-10-08-클린아키텍처_목차/</id>
    <published>2019-10-08T02:50:50.000Z</published>
    <updated>2020-02-23T16:18:47.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1부-소개"><a href="#1부-소개" class="headerlink" title="1부 소개"></a>1부 소개</h1><h3 id="1장-설계와-아키텍처란"><a href="#1장-설계와-아키텍처란" class="headerlink" title="1장 설계와 아키텍처란?"></a>1장 설계와 아키텍처란?</h3><ul><li>목표는?</li><li>사례 연구</li><li>결론</li></ul><h3 id="2장-두-가지-가치에-대한-이야기"><a href="#2장-두-가지-가치에-대한-이야기" class="headerlink" title="2장 두 가지 가치에 대한 이야기"></a>2장 두 가지 가치에 대한 이야기</h3><ul><li>행위</li><li>아키텍처</li><li>더 높은 가치</li><li>아이젠하워 매트릭스</li><li>아키텍처를 위해 투쟁하라</li></ul><hr><h1 id="2부-벽돌부터-시작하기-프로그래밍-패러다임"><a href="#2부-벽돌부터-시작하기-프로그래밍-패러다임" class="headerlink" title="2부 벽돌부터 시작하기: 프로그래밍 패러다임"></a>2부 벽돌부터 시작하기: 프로그래밍 패러다임</h1><h3 id="3장-패러다임-개요"><a href="#3장-패러다임-개요" class="headerlink" title="3장 패러다임 개요"></a>3장 패러다임 개요</h3><ul><li>구조적 프로그래밍</li><li>객체 지향 프로그래밍</li><li>함수형 프로그래밍</li><li>생각할 거리</li><li>결론</li></ul><h3 id="4장-구조적-프로그래밍"><a href="#4장-구조적-프로그래밍" class="headerlink" title="4장 구조적 프로그래밍"></a>4장 구조적 프로그래밍</h3><ul><li>증명</li><li>해로운 성명서</li><li>기능적 분해</li><li>엄밀한 증명은 없었다</li><li>과학이 구출하다</li><li>테스트</li><li>결론</li></ul><h3 id="5장-객체-지향-프로그래밍"><a href="#5장-객체-지향-프로그래밍" class="headerlink" title="5장 객체 지향 프로그래밍"></a>5장 객체 지향 프로그래밍</h3><ul><li>캡슐화?</li><li>상속?</li><li>다형성?</li><li>결론</li></ul><h3 id="6장-함수형-프로그래밍"><a href="#6장-함수형-프로그래밍" class="headerlink" title="6장 함수형 프로그래밍"></a>6장 함수형 프로그래밍</h3><ul><li>정수를 제곱하기</li><li>불변성과 아키텍처</li><li>가변성의 분리</li><li>이벤트 소싱</li><li>결론</li></ul><hr><a id="more"></a><h1 id="3부-설계-원칙"><a href="#3부-설계-원칙" class="headerlink" title="3부 설계 원칙"></a>3부 설계 원칙</h1><h3 id="7장-SRP-단일-책임-원칙"><a href="#7장-SRP-단일-책임-원칙" class="headerlink" title="7장 SRP: 단일 책임 원칙"></a>7장 SRP: 단일 책임 원칙</h3><ul><li>징후 1: 우발적 중복</li><li>징후 2: 병합</li><li>해결책</li><li>결론</li></ul><h3 id="8장-OCP-개방-폐쇄-원칙"><a href="#8장-OCP-개방-폐쇄-원칙" class="headerlink" title="8장 OCP: 개방-폐쇄 원칙"></a>8장 OCP: 개방-폐쇄 원칙</h3><ul><li>사고 실험</li><li>방향성 제어</li><li>정보 은닉</li><li>결론</li></ul><h3 id="9장-LSP-리스코프-치환-원칙"><a href="#9장-LSP-리스코프-치환-원칙" class="headerlink" title="9장 LSP: 리스코프 치환 원칙"></a>9장 LSP: 리스코프 치환 원칙</h3><ul><li>상속을 사용하도록 가이드하기</li><li>정사각형/직사각형 문제</li><li>LSP와 아키텍처</li><li>LSP 위배 사례</li><li>결론</li></ul><h3 id="10장-ISP-인터페이스-분리-원칙"><a href="#10장-ISP-인터페이스-분리-원칙" class="headerlink" title="10장 ISP: 인터페이스 분리 원칙"></a>10장 ISP: 인터페이스 분리 원칙</h3><ul><li>ISP와 언어</li><li>ISP와 아키텍처</li><li>결론</li></ul><h3 id="11장-DIP-의존성-역전-원칙"><a href="#11장-DIP-의존성-역전-원칙" class="headerlink" title="11장 DIP: 의존성 역전 원칙"></a>11장 DIP: 의존성 역전 원칙</h3><ul><li>안정된 추상화</li><li>팩토리</li><li>구체 컴포넌트</li><li>결론</li></ul><hr><h1 id="4부-컴포넌트-원칙"><a href="#4부-컴포넌트-원칙" class="headerlink" title="4부 컴포넌트 원칙"></a>4부 컴포넌트 원칙</h1><h3 id="12장-컴포넌트"><a href="#12장-컴포넌트" class="headerlink" title="12장 컴포넌트"></a>12장 컴포넌트</h3><ul><li>컴포넌트의 간략한 역사</li><li>재배치성</li><li>링커</li><li>결론</li></ul><h3 id="13장-컴포넌트-응집도"><a href="#13장-컴포넌트-응집도" class="headerlink" title="13장 컴포넌트 응집도"></a>13장 컴포넌트 응집도</h3><ul><li>REP: 재사용/릴리스 등가 원칙</li><li>CCP: 공통 폐쇄 원칙</li><li>CRP: 공통 재사용 원칙</li><li>컴포넌트 응집도에 대한 균형 다이어그램</li><li>결론</li></ul><h3 id="14장-컴포넌트-결합"><a href="#14장-컴포넌트-결합" class="headerlink" title="14장 컴포넌트 결합"></a>14장 컴포넌트 결합</h3><ul><li>ADP: 의존성 비순환 원칙</li><li>하향식(top-down) 설계</li><li>SDP: 안정된 의존성 원칙</li><li>SAP: 안정된 추상화 원칙</li><li>결론</li></ul><hr><h1 id="5부-아키텍처"><a href="#5부-아키텍처" class="headerlink" title="5부 아키텍처"></a>5부 아키텍처</h1><h3 id="15장-아키텍처란"><a href="#15장-아키텍처란" class="headerlink" title="15장 아키텍처란?"></a>15장 아키텍처란?</h3><ul><li>개발</li><li>배포</li><li>운영</li><li>유지보수</li><li>선택사항 열어 두기</li><li>장치 독립성</li><li>광고 우편</li><li>물리적 주소 할당</li><li>결론</li></ul><h3 id="16장-독립성"><a href="#16장-독립성" class="headerlink" title="16장 독립성"></a>16장 독립성</h3><ul><li>유스케이스</li><li>운영</li><li>개발</li><li>배포</li><li>선택사항 열어놓기</li><li>계층 결합 분리</li><li>유스케이스 결합 분리</li><li>결합 분리 모드</li><li>개발 독립성</li><li>배포 독립성</li><li>중복</li><li>결합 분리 모드(다시)</li><li>결론</li></ul><h3 id="17장-경계-선-긋기"><a href="#17장-경계-선-긋기" class="headerlink" title="17장 경계: 선 긋기"></a>17장 경계: 선 긋기</h3><ul><li>두 가지 슬픈 이야기</li><li>FitNesse</li><li>어떻게 선을 그을까? 그리고 언제 그을까?</li><li>입력과 출력은?</li><li>플러그인 아키텍처</li><li>플러그인에 대한 논의</li><li>결론</li></ul><h3 id="18장-경계-해부학"><a href="#18장-경계-해부학" class="headerlink" title="18장 경계 해부학"></a>18장 경계 해부학</h3><ul><li>경계 횡단하기</li><li>두려운 단일체</li><li>배포형 컴포넌트</li><li>스레드</li><li>로컬 프로세스</li><li>서비스</li><li>결론</li></ul><h3 id="19장-정책과-수준"><a href="#19장-정책과-수준" class="headerlink" title="19장 정책과 수준"></a>19장 정책과 수준</h3><ul><li>수준</li><li>결론</li></ul><h3 id="20장-업무-규칙"><a href="#20장-업무-규칙" class="headerlink" title="20장 업무 규칙"></a>20장 업무 규칙</h3><ul><li>엔티티</li><li>유스케이스</li><li>요청 및 응답 모델</li><li>결론</li></ul><h3 id="21장-소리치는-아키텍처"><a href="#21장-소리치는-아키텍처" class="headerlink" title="21장 소리치는 아키텍처"></a>21장 소리치는 아키텍처</h3><ul><li>아키텍처의 테마</li><li>아키텍처의 목적</li><li>하지만 웹은?</li><li>프레임워크는 도구일 뿐, 삶의 방식은 아니다</li><li>테스트하기 쉬운 아키텍처</li><li>결론</li></ul><h3 id="22장-클린-아키텍처"><a href="#22장-클린-아키텍처" class="headerlink" title="22장 클린 아키텍처"></a>22장 클린 아키텍처</h3><ul><li>의존성 규칙</li><li>전형적인 시나리오</li><li>결론</li></ul><h3 id="23장-프레젠터와-험블-객체"><a href="#23장-프레젠터와-험블-객체" class="headerlink" title="23장 프레젠터와 험블 객체"></a>23장 프레젠터와 험블 객체</h3><ul><li>험블 객체 패턴</li><li>프레젠터와 뷰</li><li>테스트와 아키텍처</li><li>데이터베이스 게이트웨이</li><li>데이터 매퍼</li><li>서비스 리스너</li><li>결론</li></ul><h3 id="24장-부분적-경계"><a href="#24장-부분적-경계" class="headerlink" title="24장 부분적 경계"></a>24장 부분적 경계</h3><ul><li>마지막 단계를 건너뛰기</li><li>일차원 경계</li><li>퍼사드</li><li>결론</li></ul><h3 id="25장-계층과-경계"><a href="#25장-계층과-경계" class="headerlink" title="25장 계층과 경계"></a>25장 계층과 경계</h3><ul><li>움퍼스 사냥 게임</li><li>클린 아키텍처?</li><li>흐름 횡단하기</li><li>흐름 분리하기</li><li>결론</li></ul><h3 id="26장-메인-Main-컴포넌트"><a href="#26장-메인-Main-컴포넌트" class="headerlink" title="26장 메인(Main) 컴포넌트"></a>26장 메인(Main) 컴포넌트</h3><ul><li>궁극적인 세부사항</li><li>결론</li></ul><h3 id="27장-‘크고-작은-모든’-서비스들"><a href="#27장-‘크고-작은-모든’-서비스들" class="headerlink" title="27장 ‘크고 작은 모든’ 서비스들"></a>27장 ‘크고 작은 모든’ 서비스들</h3><ul><li>서비스 아키텍처?</li><li>서비스의 이점?</li><li>야옹이 문제</li><li>객체가 구출하다</li><li>컴포넌트 기반 서비스</li><li>횡단 관심사</li><li>결론</li></ul><h3 id="28장-테스트-경계"><a href="#28장-테스트-경계" class="headerlink" title="28장 테스트 경계"></a>28장 테스트 경계</h3><ul><li>시스템 컴포넌트인 테스트</li><li>테스트를 고려한 설계</li><li>테스트 API</li><li>결론</li></ul><h3 id="29장-클린-임베디드-아키텍처"><a href="#29장-클린-임베디드-아키텍처" class="headerlink" title="29장 클린 임베디드 아키텍처"></a>29장 클린 임베디드 아키텍처</h3><ul><li>앱-티튜드 테스트</li><li>타깃-하드웨어 병목현상</li><li>결론</li></ul><hr><h1 id="6부-세부사항"><a href="#6부-세부사항" class="headerlink" title="6부 세부사항"></a>6부 세부사항</h1><h3 id="30장-데이터베이스는-세부사항이다"><a href="#30장-데이터베이스는-세부사항이다" class="headerlink" title="30장 데이터베이스는 세부사항이다"></a>30장 데이터베이스는 세부사항이다</h3><ul><li>관계형 데이터베이스</li><li>데이터베이스 시스템은 왜 이렇게 널리 사용되는가?</li><li>디스크가 없다면 어떻게 될까?</li><li>세부사항</li><li>하지만 성능은?</li><li>개인적인 일화</li><li>결론</li></ul><h3 id="31장-웹은-세부사항이다"><a href="#31장-웹은-세부사항이다" class="headerlink" title="31장 웹은 세부사항이다"></a>31장 웹은 세부사항이다</h3><ul><li>끝없이 반복하는 추</li><li>요약</li><li>결론</li></ul><h3 id="32장-프레임워크는-세부사항이다"><a href="#32장-프레임워크는-세부사항이다" class="headerlink" title="32장 프레임워크는 세부사항이다"></a>32장 프레임워크는 세부사항이다</h3><ul><li>프레임워크 제작자</li><li>혼인 관계의 비대칭성</li><li>위험 요인</li><li>해결책</li><li>이제 선언합니다</li><li>결론</li></ul><h3 id="33장-사례-연구-비디오-판매"><a href="#33장-사례-연구-비디오-판매" class="headerlink" title="33장 사례 연구: 비디오 판매"></a>33장 사례 연구: 비디오 판매</h3><ul><li>제품</li><li>유스케이스 분석</li><li>컴포넌트 아키텍처</li><li>의존성 관리</li><li>결론</li></ul><h3 id="34장-빠져-있는-장"><a href="#34장-빠져-있는-장" class="headerlink" title="34장 빠져 있는 장"></a>34장 빠져 있는 장</h3><ul><li>계층 기반 패키지</li><li>기능 기반 패키지</li><li>포트와 어댑터</li><li>컴포넌트 기반 패키지</li><li>구현 세부사항엔 항상 문제가 있다</li><li>조직화 vs. 캡슐화</li><li>다른 결합 분리 모드</li><li>결론: 빠져 있는 조언</li></ul><hr><h1 id="7부-부록"><a href="#7부-부록" class="headerlink" title="7부 부록"></a>7부 부록</h1><p>부록 A 아키텍처 고고학</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1부-소개&quot;&gt;&lt;a href=&quot;#1부-소개&quot; class=&quot;headerlink&quot; title=&quot;1부 소개&quot;&gt;&lt;/a&gt;1부 소개&lt;/h1&gt;&lt;h3 id=&quot;1장-설계와-아키텍처란&quot;&gt;&lt;a href=&quot;#1장-설계와-아키텍처란&quot; class=&quot;headerlink&quot; title=&quot;1장 설계와 아키텍처란?&quot;&gt;&lt;/a&gt;1장 설계와 아키텍처란?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;목표는?&lt;/li&gt;
&lt;li&gt;사례 연구&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2장-두-가지-가치에-대한-이야기&quot;&gt;&lt;a href=&quot;#2장-두-가지-가치에-대한-이야기&quot; class=&quot;headerlink&quot; title=&quot;2장 두 가지 가치에 대한 이야기&quot;&gt;&lt;/a&gt;2장 두 가지 가치에 대한 이야기&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;행위&lt;/li&gt;
&lt;li&gt;아키텍처&lt;/li&gt;
&lt;li&gt;더 높은 가치&lt;/li&gt;
&lt;li&gt;아이젠하워 매트릭스&lt;/li&gt;
&lt;li&gt;아키텍처를 위해 투쟁하라&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;2부-벽돌부터-시작하기-프로그래밍-패러다임&quot;&gt;&lt;a href=&quot;#2부-벽돌부터-시작하기-프로그래밍-패러다임&quot; class=&quot;headerlink&quot; title=&quot;2부 벽돌부터 시작하기: 프로그래밍 패러다임&quot;&gt;&lt;/a&gt;2부 벽돌부터 시작하기: 프로그래밍 패러다임&lt;/h1&gt;&lt;h3 id=&quot;3장-패러다임-개요&quot;&gt;&lt;a href=&quot;#3장-패러다임-개요&quot; class=&quot;headerlink&quot; title=&quot;3장 패러다임 개요&quot;&gt;&lt;/a&gt;3장 패러다임 개요&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;구조적 프로그래밍&lt;/li&gt;
&lt;li&gt;객체 지향 프로그래밍&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍&lt;/li&gt;
&lt;li&gt;생각할 거리&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4장-구조적-프로그래밍&quot;&gt;&lt;a href=&quot;#4장-구조적-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;4장 구조적 프로그래밍&quot;&gt;&lt;/a&gt;4장 구조적 프로그래밍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;증명&lt;/li&gt;
&lt;li&gt;해로운 성명서&lt;/li&gt;
&lt;li&gt;기능적 분해&lt;/li&gt;
&lt;li&gt;엄밀한 증명은 없었다&lt;/li&gt;
&lt;li&gt;과학이 구출하다&lt;/li&gt;
&lt;li&gt;테스트&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5장-객체-지향-프로그래밍&quot;&gt;&lt;a href=&quot;#5장-객체-지향-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;5장 객체 지향 프로그래밍&quot;&gt;&lt;/a&gt;5장 객체 지향 프로그래밍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;캡슐화?&lt;/li&gt;
&lt;li&gt;상속?&lt;/li&gt;
&lt;li&gt;다형성?&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;6장-함수형-프로그래밍&quot;&gt;&lt;a href=&quot;#6장-함수형-프로그래밍&quot; class=&quot;headerlink&quot; title=&quot;6장 함수형 프로그래밍&quot;&gt;&lt;/a&gt;6장 함수형 프로그래밍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;정수를 제곱하기&lt;/li&gt;
&lt;li&gt;불변성과 아키텍처&lt;/li&gt;
&lt;li&gt;가변성의 분리&lt;/li&gt;
&lt;li&gt;이벤트 소싱&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="도서" scheme="https://dschoi.github.io/categories/%EB%8F%84%EC%84%9C/"/>
    
    
      <category term="clean architecture" scheme="https://dschoi.github.io/tags/clean-architecture/"/>
    
  </entry>
  
</feed>
